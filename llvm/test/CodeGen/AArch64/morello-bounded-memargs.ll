; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=aarch64 -mattr=+morello,+c64,+bounded-morello-memargs-callee -target-abi purecap -o - %s | FileCheck %s

target datalayout = "e-m:e-pf200:128:128:128:64-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128-A200-P200-G200"
target triple = "aarch64-none-unknown-elf"

define i32 @foo(i32 %x, i32 %y, i32 %z, i32 %u, i32 %v, i32 %w, i32 %t1, i32 %t2, i32 %t3, i32 addrspace(200)* %t4) addrspace(200) {
; CHECK-LABEL: foo:
; CHECK:       .Lfunc_begin0:
; CHECK-NEXT:    .cfi_startproc purecap
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    str c30, [csp, #-48]! // 16-byte Folded Spill
; CHECK-NEXT:    stp c20, c19, [csp, #16] // 32-byte Folded Spill
; CHECK-NEXT:    .cfi_def_cfa_offset 48
; CHECK-NEXT:    .cfi_offset c19, -16
; CHECK-NEXT:    .cfi_offset c20, -32
; CHECK-NEXT:    .cfi_offset c30, -48
; CHECK-NEXT:    ldr w0, [c9]
; CHECK-NEXT:    ldr c19, [c9, #16]
; CHECK-NEXT:    bl bar
; CHECK-NEXT:    mov w20, w0
; CHECK-NEXT:    mov c0, c19
; CHECK-NEXT:    bl baz
; CHECK-NEXT:    add w0, w0, w20
; CHECK-NEXT:    ldp c20, c19, [csp, #16] // 32-byte Folded Reload
; CHECK-NEXT:    ldr c30, [csp], #48 // 16-byte Folded Reload
; CHECK-NEXT:    ret c30
entry:
  %call = call i32 @bar(i32 %t3)
  %call1 = call i32 @baz(i32 addrspace(200)* %t4)
  %add = add nsw i32 %call1, %call
  ret i32 %add
}

declare i32 @bar(i32) addrspace(200)

declare i32 @baz(i32 addrspace(200)*) addrspace(200)

define i32 @baf(i32 %x, i32 %y, i32 %z, i32 %u, i32 %v, i32 %w, i32 %t1, i32 %t2, i32 %t3, i32 addrspace(200)* %t4, ...) addrspace(200) {
; CHECK-LABEL: baf:
; CHECK:       .Lfunc_begin1:
; CHECK-NEXT:    .cfi_startproc purecap
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    sub csp, csp, #80 // =80
; CHECK-NEXT:    str c30, [csp, #32] // 16-byte Folded Spill
; CHECK-NEXT:    stp c20, c19, [csp, #48] // 32-byte Folded Spill
; CHECK-NEXT:    .cfi_def_cfa_offset 80
; CHECK-NEXT:    .cfi_offset c19, -16
; CHECK-NEXT:    .cfi_offset c20, -32
; CHECK-NEXT:    .cfi_offset c30, -48
; CHECK-NEXT:    add c0, c9, #32 // =32
; CHECK-NEXT:    add c1, csp, #16 // =16
; CHECK-NEXT:    str c0, [csp, #0]
; CHECK-NEXT:    scbnds c1, c1, #16 // =16
; CHECK-NEXT:    clrperm c0, c0, wx
; CHECK-NEXT:    ldr c19, [c9, #16]
; CHECK-NEXT:    ldr w20, [c9]
; CHECK-NEXT:    str c0, [c1, #0]
; CHECK-NEXT:    ldr c0, [csp, #16]
; CHECK-NEXT:    bl try
; CHECK-NEXT:    mov w0, w20
; CHECK-NEXT:    bl bar
; CHECK-NEXT:    mov w20, w0
; CHECK-NEXT:    mov c0, c19
; CHECK-NEXT:    bl baz
; CHECK-NEXT:    add w0, w0, w20
; CHECK-NEXT:    ldp c20, c19, [csp, #48] // 32-byte Folded Reload
; CHECK-NEXT:    ldr c30, [csp, #32] // 16-byte Folded Reload
; CHECK-NEXT:    add csp, csp, #80 // =80
; CHECK-NEXT:    ret c30
entry:
  %va = alloca i8 addrspace(200)*, align 16, addrspace(200)
  %0 = bitcast i8 addrspace(200)* addrspace(200)* %va to i8 addrspace(200)*
  call void @llvm.lifetime.start.p200i8(i64 16, i8 addrspace(200)* nonnull %0)
  call void @llvm.va_start.p200i8(i8 addrspace(200)* nonnull %0)
  %1 = load i8 addrspace(200)*, i8 addrspace(200)* addrspace(200)* %va, align 16
  call void @try(i8 addrspace(200)* %1)
  %call = call i32 @bar(i32 %t3)
  %call2 = call i32 @baz(i32 addrspace(200)* %t4)
  %add = add nsw i32 %call2, %call
  call void @llvm.lifetime.end.p200i8(i64 16, i8 addrspace(200)* nonnull %0)
  ret i32 %add
}

declare void @llvm.lifetime.start.p200i8(i64 immarg, i8 addrspace(200)* nocapture) addrspace(200)

declare void @llvm.va_start.p200i8(i8 addrspace(200)*) addrspace(200)

declare void @try(i8 addrspace(200)*) local_unnamed_addr addrspace(200)

declare void @llvm.lifetime.end.p200i8(i64 immarg, i8 addrspace(200)* nocapture) addrspace(200)

define i32 @bb([4 x float] %f1.coerce, [4 x float] %f2.coerce, [4 x float] %f3.coerce, ...) addrspace(200) {
; CHECK-LABEL: bb:
; CHECK:       .Lfunc_begin2:
; CHECK-NEXT:    .cfi_startproc purecap
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    .cfi_def_cfa_offset 32
; CHECK-NEXT:    add c0, c9, #16 // =16
; CHECK-NEXT:    str c0, [csp, #-32]!
; CHECK-NEXT:    add c1, csp, #16 // =16
; CHECK-NEXT:    scbnds c1, c1, #16 // =16
; CHECK-NEXT:    clrperm c0, c0, wx
; CHECK-NEXT:    ldr s0, [c9, #12]
; CHECK-NEXT:    ldp s2, s1, [c9]
; CHECK-NEXT:    str c0, [c1, #0]
; CHECK-NEXT:    ldr c0, [csp, #16]
; CHECK-NEXT:    fadd s1, s2, s1
; CHECK-NEXT:    fadd s0, s0, s1
; CHECK-NEXT:    add c1, c0, #16 // =16
; CHECK-NEXT:    str c1, [csp, #16]
; CHECK-NEXT:    ldr d3, [c0]
; CHECK-NEXT:    fadd s0, s7, s0
; CHECK-NEXT:    fcvt s1, d3
; CHECK-NEXT:    fadd s0, s0, s1
; CHECK-NEXT:    fcvtzs w0, s0
; CHECK-NEXT:    add csp, csp, #32 // =32
; CHECK-NEXT:    ret c30
entry:
  %va = alloca i8 addrspace(200)*, align 16, addrspace(200)
  %f2.coerce.fca.3.extract = extractvalue [4 x float] %f2.coerce, 3
  %f3.coerce.fca.0.extract = extractvalue [4 x float] %f3.coerce, 0
  %f3.coerce.fca.1.extract = extractvalue [4 x float] %f3.coerce, 1
  %f3.coerce.fca.3.extract = extractvalue [4 x float] %f3.coerce, 3
  %add = fadd float %f3.coerce.fca.0.extract, %f3.coerce.fca.1.extract
  %add3 = fadd float %f3.coerce.fca.3.extract, %add
  %add5 = fadd float %f2.coerce.fca.3.extract, %add3
  %0 = bitcast i8 addrspace(200)* addrspace(200)* %va to i8 addrspace(200)*
  call void @llvm.lifetime.start.p200i8(i64 16, i8 addrspace(200)* nonnull %0)
  call void @llvm.va_start.p200i8(i8 addrspace(200)* nonnull %0)
  %stack = load i8 addrspace(200)*, i8 addrspace(200)* addrspace(200)* %va, align 16
  %1 = bitcast i8 addrspace(200)* %stack to double addrspace(200)*
  %new_stack = getelementptr inbounds i8, i8 addrspace(200)* %stack, i64 16
  store i8 addrspace(200)* %new_stack, i8 addrspace(200)* addrspace(200)* %va, align 16
  %2 = load double, double addrspace(200)* %1, align 16
  %conv = fptrunc double %2 to float
  %add7 = fadd float %add5, %conv
  %conv8 = fptosi float %add7 to i32
  call void @llvm.lifetime.end.p200i8(i64 16, i8 addrspace(200)* nonnull %0)
  ret i32 %conv8
}

define i32 @biz() local_unnamed_addr addrspace(200) {
; CHECK-LABEL: biz:
; CHECK:       .Lfunc_begin3:
; CHECK-NEXT:    .cfi_startproc purecap
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    sub csp, csp, #112 // =112
; CHECK-NEXT:    str c30, [csp, #64] // 16-byte Folded Spill
; CHECK-NEXT:    stp c20, c19, [csp, #80] // 32-byte Folded Spill
; CHECK-NEXT:    .cfi_def_cfa_offset 112
; CHECK-NEXT:    .cfi_offset c19, -16
; CHECK-NEXT:    .cfi_offset c20, -32
; CHECK-NEXT:    .cfi_offset c30, -48
; CHECK-NEXT:    mov w8, #1
; CHECK-NEXT:    mov w20, #8
; CHECK-NEXT:    scbnds c9, csp, #4, lsl #4 // =64
; CHECK-NEXT:    mov w1, #1
; CHECK-NEXT:    mov w2, #2
; CHECK-NEXT:    mov w3, #3
; CHECK-NEXT:    mov w4, #4
; CHECK-NEXT:    mov w5, #5
; CHECK-NEXT:    mov w6, #6
; CHECK-NEXT:    mov w7, #7
; CHECK-NEXT:    mov w0, wzr
; CHECK-NEXT:    str czr, [csp, #16]
; CHECK-NEXT:    str x8, [csp, #48]
; CHECK-NEXT:    str x8, [csp, #32]
; CHECK-NEXT:    str w20, [csp]
; CHECK-NEXT:    bl fiz
; CHECK-NEXT:    mov w19, w0
; CHECK-NEXT:    scbnds c9, csp, #32 // =32
; CHECK-NEXT:    mov w1, #1
; CHECK-NEXT:    mov w2, #2
; CHECK-NEXT:    mov w3, #3
; CHECK-NEXT:    mov w4, #4
; CHECK-NEXT:    mov w5, #5
; CHECK-NEXT:    mov w6, #6
; CHECK-NEXT:    mov w7, #7
; CHECK-NEXT:    mov w0, wzr
; CHECK-NEXT:    str czr, [csp, #16]
; CHECK-NEXT:    str w20, [csp]
; CHECK-NEXT:    bl fiz
; CHECK-NEXT:    add w0, w0, w19
; CHECK-NEXT:    ldp c20, c19, [csp, #80] // 32-byte Folded Reload
; CHECK-NEXT:    ldr c30, [csp, #64] // 16-byte Folded Reload
; CHECK-NEXT:    add csp, csp, #112 // =112
; CHECK-NEXT:    ret c30
entry:
  %call = call i32 (i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 addrspace(200)*, ...) @fiz(i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 addrspace(200)* null, i32 1, i32 1)
  %call1 = call i32 (i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 addrspace(200)*, ...) @fiz(i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 addrspace(200)* null)
  %add = add nsw i32 %call1, %call
  ret i32 %add
}

declare i32 @fiz(i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 addrspace(200)*, ...) addrspace(200)

define i32 @f(i32 %0, i32 %1, i32 %2, i32 %3, i32 %4, i32 %5, i32 %6, i32 %7, i32 %8, ...) local_unnamed_addr addrspace(200) #0 {
; CHECK-LABEL: f:
; CHECK:       .Lfunc_begin4:
; CHECK-NEXT:    .cfi_startproc purecap
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    sub csp, csp, #32 // =32
; CHECK-NEXT:    .cfi_def_cfa_offset 32
; CHECK-NEXT:    ldr w8, [c9], #16
; CHECK-NEXT:    add c0, csp, #16 // =16
; CHECK-NEXT:    scbnds c0, c0, #16 // =16
; CHECK-NEXT:    clrperm c1, c9, wx
; CHECK-NEXT:    str c1, [c0, #0]
; CHECK-NEXT:    ldr c0, [csp, #16]
; CHECK-NEXT:    add c1, c0, #16 // =16
; CHECK-NEXT:    stp c9, c1, [csp], #32
; CHECK-NEXT:    ldr w9, [c0]
; CHECK-NEXT:    add w0, w9, w8
; CHECK-NEXT:    ret c30
  %10 = alloca i8 addrspace(200)*, align 16, addrspace(200)
  %11 = bitcast i8 addrspace(200)* addrspace(200)* %10 to i8 addrspace(200)*
  call void @llvm.lifetime.start.p200i8(i64 16, i8 addrspace(200)* nonnull %11) #3
  call void @llvm.va_start.p200i8(i8 addrspace(200)* nonnull %11)
  %12 = load i8 addrspace(200)*, i8 addrspace(200)* addrspace(200)* %10, align 16
  %13 = bitcast i8 addrspace(200)* %12 to i32 addrspace(200)*
  %14 = getelementptr inbounds i8, i8 addrspace(200)* %12, i64 16
  store i8 addrspace(200)* %14, i8 addrspace(200)* addrspace(200)* %10, align 16
  %15 = load i32, i32 addrspace(200)* %13, align 16
  call void @llvm.va_end.p200i8(i8 addrspace(200)* %11)
  %16 = add nsw i32 %15, %8
  call void @llvm.lifetime.end.p200i8(i64 16, i8 addrspace(200)* nonnull %11) #3
  ret i32 %16
}

declare void @llvm.va_end.p200i8(i8 addrspace(200)*) addrspace(200)
