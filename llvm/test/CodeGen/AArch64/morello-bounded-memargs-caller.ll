; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=aarch64 -mattr=+morello,+c64,+bounded-morello-memargs-caller -target-abi purecap -o - %s | FileCheck %s

define i32 @foo(i32 %x, i32 %y, i32 %z, i32 %u, i32 %v, i32 %w, i32 %t1, i32 %t2, i32 %t3, i32 addrspace(200)* %t4) addrspace(200) nounwind {
; CHECK-LABEL: foo:
; CHECK:       .Lfunc_begin0:
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    str c30, [csp, #-48]! // 16-byte Folded Spill
; CHECK-NEXT:    ldr w0, [csp, #48]
; CHECK-NEXT:    stp c20, c19, [csp, #16] // 32-byte Folded Spill
; CHECK-NEXT:    ldr c19, [csp, #64]
; CHECK-NEXT:    mov x9, xzr
; CHECK-NEXT:    bl bar
; CHECK-NEXT:    mov w20, w0
; CHECK-NEXT:    mov c0, c19
; CHECK-NEXT:    bl baz
; CHECK-NEXT:    add w0, w0, w20
; CHECK-NEXT:    ldp c20, c19, [csp, #16] // 32-byte Folded Reload
; CHECK-NEXT:    ldr c30, [csp], #48 // 16-byte Folded Reload
; CHECK-NEXT:    ret c30
entry:
  %call = call i32 @bar(i32 %t3)
  %call1 = call i32 @baz(i32 addrspace(200)* %t4)
  %add = add nsw i32 %call1, %call
  ret i32 %add
}

declare i32 @bar(i32) addrspace(200)

define internal i32 @baz(i32 addrspace(200)*) addrspace(200) nounwind {
; CHECK-LABEL: baz:
; CHECK:       .Lfunc_begin1:
; CHECK-NEXT:  // %bb.0:
; CHECK-NEXT:    mov w0, wzr
; CHECK-NEXT:    ret c30
  ret i32 0
}

define i32 @baf(i32 %z, i32 %u, i32 %v, i32 %w, i32 %t1, i32 %t2, i32 %t3, i32 addrspace(200)* %t4, ...) addrspace(200) nounwind {
; CHECK-LABEL: baf:
; CHECK:       .Lfunc_begin2:
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    sub csp, csp, #80 // =80
; CHECK-NEXT:    add c0, csp, #16 // =16
; CHECK-NEXT:    scbnds c0, c0, #16 // =16
; CHECK-NEXT:    str c9, [c0, #0]
; CHECK-NEXT:    ldr c0, [csp, #16]
; CHECK-NEXT:    str c9, [csp, #0]
; CHECK-NEXT:    mov x9, xzr
; CHECK-NEXT:    str c30, [csp, #32] // 16-byte Folded Spill
; CHECK-NEXT:    stp c20, c19, [csp, #48] // 32-byte Folded Spill
; CHECK-NEXT:    mov c19, c7
; CHECK-NEXT:    mov w20, w6
; CHECK-NEXT:    bl try
; CHECK-NEXT:    mov w0, w20
; CHECK-NEXT:    mov x9, xzr
; CHECK-NEXT:    bl bar
; CHECK-NEXT:    mov w20, w0
; CHECK-NEXT:    mov c0, c19
; CHECK-NEXT:    bl baz
; CHECK-NEXT:    add w0, w0, w20
; CHECK-NEXT:    ldp c20, c19, [csp, #48] // 32-byte Folded Reload
; CHECK-NEXT:    ldr c30, [csp, #32] // 16-byte Folded Reload
; CHECK-NEXT:    add csp, csp, #80 // =80
; CHECK-NEXT:    ret c30
entry:
  %va = alloca i8 addrspace(200)*, align 16, addrspace(200)
  %0 = bitcast i8 addrspace(200)* addrspace(200)* %va to i8 addrspace(200)*
  call void @llvm.lifetime.start.p200i8(i64 16, i8 addrspace(200)* nonnull %0)
  call void @llvm.va_start.p200i8(i8 addrspace(200)* nonnull %0)
  %1 = load i8 addrspace(200)*, i8 addrspace(200)* addrspace(200)* %va, align 16
  call void @try(i8 addrspace(200)* %1)
  %call = call i32 @bar(i32 %t3)
  %call2 = call i32 @baz(i32 addrspace(200)* %t4)
  %add = add nsw i32 %call2, %call
  call void @llvm.lifetime.end.p200i8(i64 16, i8 addrspace(200)* nonnull %0)
  ret i32 %add
}

declare void @llvm.lifetime.start.p200i8(i64 immarg, i8 addrspace(200)* nocapture) addrspace(200)

declare void @llvm.va_start.p200i8(i8 addrspace(200)*) addrspace(200)

declare void @try(i8 addrspace(200)*) local_unnamed_addr addrspace(200)

declare void @llvm.lifetime.end.p200i8(i64 immarg, i8 addrspace(200)* nocapture) addrspace(200)

define i32 @bb([4 x float] %f1.coerce, [4 x float] %f2.coerce, [4 x float] %f3.coerce, ...) addrspace(200) nounwind {
; CHECK-LABEL: bb:
; CHECK:       .Lfunc_begin3:
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    str c9, [csp, #-32]!
; CHECK-NEXT:    add c0, csp, #16 // =16
; CHECK-NEXT:    scbnds c0, c0, #16 // =16
; CHECK-NEXT:    str c9, [c0, #0]
; CHECK-NEXT:    ldr c0, [csp, #16]
; CHECK-NEXT:    ldp s2, s1, [csp, #32]
; CHECK-NEXT:    ldr s0, [csp, #44]
; CHECK-NEXT:    add c1, c0, #16 // =16
; CHECK-NEXT:    str c1, [csp, #16]
; CHECK-NEXT:    ldr d3, [c0]
; CHECK-NEXT:    fadd s1, s2, s1
; CHECK-NEXT:    fadd s0, s0, s1
; CHECK-NEXT:    fadd s0, s7, s0
; CHECK-NEXT:    fcvt s1, d3
; CHECK-NEXT:    fadd s0, s0, s1
; CHECK-NEXT:    fcvtzs w0, s0
; CHECK-NEXT:    add csp, csp, #32 // =32
; CHECK-NEXT:    ret c30
entry:
  %va = alloca i8 addrspace(200)*, align 16, addrspace(200)
  %f2.coerce.fca.3.extract = extractvalue [4 x float] %f2.coerce, 3
  %f3.coerce.fca.0.extract = extractvalue [4 x float] %f3.coerce, 0
  %f3.coerce.fca.1.extract = extractvalue [4 x float] %f3.coerce, 1
  %f3.coerce.fca.3.extract = extractvalue [4 x float] %f3.coerce, 3
  %add = fadd float %f3.coerce.fca.0.extract, %f3.coerce.fca.1.extract
  %add3 = fadd float %f3.coerce.fca.3.extract, %add
  %add5 = fadd float %f2.coerce.fca.3.extract, %add3
  %0 = bitcast i8 addrspace(200)* addrspace(200)* %va to i8 addrspace(200)*
  call void @llvm.lifetime.start.p200i8(i64 16, i8 addrspace(200)* nonnull %0)
  call void @llvm.va_start.p200i8(i8 addrspace(200)* nonnull %0)
  %stack = load i8 addrspace(200)*, i8 addrspace(200)* addrspace(200)* %va, align 16
  %1 = bitcast i8 addrspace(200)* %stack to double addrspace(200)*
  %new_stack = getelementptr inbounds i8, i8 addrspace(200)* %stack, i64 16
  store i8 addrspace(200)* %new_stack, i8 addrspace(200)* addrspace(200)* %va, align 16
  %2 = load double, double addrspace(200)* %1, align 16
  %conv = fptrunc double %2 to float
  %add7 = fadd float %add5, %conv
  %conv8 = fptosi float %add7 to i32
  call void @llvm.lifetime.end.p200i8(i64 16, i8 addrspace(200)* nonnull %0)
  ret i32 %conv8
}

define i32 @biz() local_unnamed_addr addrspace(200) nounwind {
; CHECK-LABEL: biz:
; CHECK:       .Lfunc_begin4:
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    sub csp, csp, #64 // =64
; CHECK-NEXT:    mov w8, #1
; CHECK-NEXT:    scbnds c9, csp, #32 // =32
; CHECK-NEXT:    mov w1, #1
; CHECK-NEXT:    mov w2, #2
; CHECK-NEXT:    mov w3, #3
; CHECK-NEXT:    mov w4, #4
; CHECK-NEXT:    mov w5, #5
; CHECK-NEXT:    mov w6, #6
; CHECK-NEXT:    mov w0, wzr
; CHECK-NEXT:    mov x7, xzr
; CHECK-NEXT:    stp c30, c19, [csp, #32] // 32-byte Folded Spill
; CHECK-NEXT:    str x8, [csp, #16]
; CHECK-NEXT:    str x8, [csp]
; CHECK-NEXT:    bl fiz
; CHECK-NEXT:    mov w19, w0
; CHECK-NEXT:    mov w1, #1
; CHECK-NEXT:    mov w2, #2
; CHECK-NEXT:    mov w3, #3
; CHECK-NEXT:    mov w4, #4
; CHECK-NEXT:    mov w5, #5
; CHECK-NEXT:    mov w6, #6
; CHECK-NEXT:    mov w0, wzr
; CHECK-NEXT:    mov x7, xzr
; CHECK-NEXT:    mov x9, xzr
; CHECK-NEXT:    bl fiz
; CHECK-NEXT:    add w0, w0, w19
; CHECK-NEXT:    ldp c30, c19, [csp, #32] // 32-byte Folded Reload
; CHECK-NEXT:    add csp, csp, #64 // =64
; CHECK-NEXT:    ret c30
entry:
  %call = call i32 (i32, i32, i32, i32, i32, i32, i32, i32 addrspace(200)*, ...) @fiz(i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 addrspace(200)* null, i32 1, i32 1)
  %call1 = call i32 (i32, i32, i32, i32, i32, i32, i32, i32 addrspace(200)*, ...) @fiz(i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 addrspace(200)* null)
  %add = add nsw i32 %call1, %call
  ret i32 %add
}

declare i32 @fiz(i32, i32, i32, i32, i32, i32, i32, i32 addrspace(200)*, ...) addrspace(200)
