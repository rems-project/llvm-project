; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=aarch64-none-elf -mattr=+c64,+morello -target-abi purecap -o - %s | FileCheck %s

target datalayout = "e-m:e-pf200:128:128:128:64-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128-A200-P200-G200"
target triple = "aarch64-none-unknown-elf"

%struct.inmem = type { float, float, float, float, [4 x i32] }

define i32 @caller_test_scalars(i32 %x, i128 %y, i64 %z, float %f, double %d) local_unnamed_addr addrspace(200) #0 {
; CHECK-LABEL: caller_test_scalars:
; CHECK:       .Lfunc_begin0:
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    sub csp, csp, #96
; CHECK-NEXT:    fcvt d0, s0
; CHECK-NEXT:    mov w8, w0
; CHECK-NEXT:    scbnds c0, csp, #5, lsl #4 // =80
; CHECK-NEXT:    str c30, [csp, #80] // 16-byte Folded Spill
; CHECK-NEXT:    clrperm c9, c0, wx
; CHECK-NEXT:    mov w0, #5
; CHECK-NEXT:    str d1, [csp, #64]
; CHECK-NEXT:    str d0, [csp, #48]
; CHECK-NEXT:    stp x3, x4, [csp, #24]
; CHECK-NEXT:    str x2, [csp, #16]
; CHECK-NEXT:    str x8, [csp]
; CHECK-NEXT:    bl callee
; CHECK-NEXT:    ldr c30, [csp, #80] // 16-byte Folded Reload
; CHECK-NEXT:    add csp, csp, #96
; CHECK-NEXT:    ret c30
entry:
  %conv = fpext float %f to double
  %call = tail call i32 (i32, ...) @callee(i32 5, i32 %x, i128 %y, i64 %z, double %conv, double %d) #0
  ret i32 %call
}

declare i32 @callee(i32, ...) local_unnamed_addr addrspace(200) #0

; Function Attrs: nounwind
define i32 @caller_test_struct(i32 %x, [2 x float] %y.coerce, i32 %z, { i8 addrspace(200)*, i64 } %u.coerce) local_unnamed_addr addrspace(200) #0 {
; CHECK-LABEL: caller_test_struct:
; CHECK:       .Lfunc_begin1:
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    sub csp, csp, #96
; CHECK-NEXT:    mov w8, w0
; CHECK-NEXT:    scbnds c0, csp, #5, lsl #4 // =80
; CHECK-NEXT:    clrperm c9, c0, wx
; CHECK-NEXT:    mov w0, #3
; CHECK-NEXT:    str c30, [csp, #80] // 16-byte Folded Spill
; CHECK-NEXT:    // kill: def $w1 killed $w1 def $x1
; CHECK-NEXT:    str x3, [csp, #64]
; CHECK-NEXT:    str x1, [csp, #32]
; CHECK-NEXT:    str c2, [csp, #48]
; CHECK-NEXT:    stp s0, s1, [csp, #16]
; CHECK-NEXT:    str x8, [csp]
; CHECK-NEXT:    bl callee
; CHECK-NEXT:    ldr c30, [csp, #80] // 16-byte Folded Reload
; CHECK-NEXT:    add csp, csp, #96
; CHECK-NEXT:    ret c30
entry:
  %call = tail call i32 (i32, ...) @callee(i32 3, i32 %x, [2 x float] %y.coerce, i32 %z, { i8 addrspace(200)*, i64 } %u.coerce) #0
  ret i32 %call
}

define i32 @caller_test_inmem_struct(%struct.inmem addrspace(200)* nocapture readonly %x) local_unnamed_addr addrspace(200) #0 {
; CHECK-LABEL: caller_test_inmem_struct:
; CHECK:       .Lfunc_begin2:
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    sub csp, csp, #64
; CHECK-NEXT:    ldp q1, q0, [c0]
; CHECK-NEXT:    scbnds c0, csp, #16 // =16
; CHECK-NEXT:    add c1, csp, #16
; CHECK-NEXT:    clrperm c9, c0, wx
; CHECK-NEXT:    mov w0, #1
; CHECK-NEXT:    scbnds c1, c1, #32 // =32
; CHECK-NEXT:    str c30, [csp, #48] // 16-byte Folded Spill
; CHECK-NEXT:    stp q1, q0, [c1]
; CHECK-NEXT:    str c1, [csp, #0]
; CHECK-NEXT:    bl callee
; CHECK-NEXT:    ldr c30, [csp, #48] // 16-byte Folded Reload
; CHECK-NEXT:    add csp, csp, #64
; CHECK-NEXT:    ret c30
entry:
  %byval-temp = alloca %struct.inmem, align 4, addrspace(200)
  %0 = bitcast %struct.inmem addrspace(200)* %byval-temp to i8 addrspace(200)*
  call void @llvm.lifetime.start.p200i8(i64 32, i8 addrspace(200)* nonnull %0) #0
  %1 = bitcast %struct.inmem addrspace(200)* %x to i8 addrspace(200)*
  call void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* nonnull align 4 dereferenceable(32) %0, i8 addrspace(200)* nonnull align 4 dereferenceable(32) %1, i64 32, i1 false) no_preserve_cheri_tags
  %call = call i32 (i32, ...) @callee(i32 1, %struct.inmem addrspace(200)* nonnull %byval-temp) #0
  call void @llvm.lifetime.end.p200i8(i64 32, i8 addrspace(200)* nonnull %0) #0
  ret i32 %call
}

define i32 @test_noargs() local_unnamed_addr addrspace(200) #0 {
; CHECK-LABEL: test_noargs:
; CHECK:       .Lfunc_begin3:
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    str c30, [csp, #-16]! // 16-byte Folded Spill
; CHECK-NEXT:    mov w0, #100
; CHECK-NEXT:    mov x9, xzr
; CHECK-NEXT:    bl callee
; CHECK-NEXT:    ldr c30, [csp], #16 // 16-byte Folded Reload
; CHECK-NEXT:    ret c30
entry:
  %call = tail call i32 (i32, ...) @callee(i32 100) #0
  ret i32 %call
}

declare void @llvm.lifetime.start.p200i8(i64 immarg, i8 addrspace(200)* nocapture) addrspace(200) #0

declare void @llvm.memcpy.p200i8.p200i8.i64(i8 addrspace(200)* noalias nocapture writeonly, i8 addrspace(200)* noalias nocapture readonly, i64, i1 immarg) addrspace(200) #0

declare void @llvm.lifetime.end.p200i8(i64 immarg, i8 addrspace(200)* nocapture) addrspace(200) #0

define void @callee_test_scalars(i32 %count, ...) local_unnamed_addr addrspace(200) #0 {
; CHECK-LABEL: callee_test_scalars:
; CHECK:       .Lfunc_begin4:
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    sub csp, csp, #48
; CHECK-NEXT:    add c0, csp, #16
; CHECK-NEXT:    str c9, [csp, #0]
; CHECK-NEXT:    scbnds c0, c0, #16 // =16
; CHECK-NEXT:    str c9, [c0, #0]
; CHECK-NEXT:    ldr c0, [csp, #16]
; CHECK-NEXT:    mov c1, c0
; CHECK-NEXT:    ldr s1, [c1, #16]!
; CHECK-NEXT:    stp c1, c30, [csp, #16] // 16-byte Folded Spill
; CHECK-NEXT:    ldr d0, [c0], #32
; CHECK-NEXT:    str c0, [csp, #16]
; CHECK-NEXT:    bl call1
; CHECK-NEXT:    ldr c30, [csp, #32] // 16-byte Folded Reload
; CHECK-NEXT:    add csp, csp, #48
; CHECK-NEXT:    ret c30
entry:
  %args = alloca i8 addrspace(200)*, align 16, addrspace(200)
  %0 = bitcast i8 addrspace(200)* addrspace(200)* %args to i8 addrspace(200)*
  call void @llvm.lifetime.start.p200i8(i64 16, i8 addrspace(200)* nonnull %0) #0
  call void @llvm.va_start.p200i8(i8 addrspace(200)* nonnull %0)
  %stack = load i8 addrspace(200)*, i8 addrspace(200)* addrspace(200)* %args, align 16
  %1 = bitcast i8 addrspace(200)* %stack to double addrspace(200)*
  %new_stack = getelementptr inbounds i8, i8 addrspace(200)* %stack, i64 16
  store i8 addrspace(200)* %new_stack, i8 addrspace(200)* addrspace(200)* %args, align 16
  %2 = load double, double addrspace(200)* %1, align 16
  %3 = bitcast i8 addrspace(200)* %new_stack to float addrspace(200)*
  %new_stack4 = getelementptr inbounds i8, i8 addrspace(200)* %stack, i64 32
  store i8 addrspace(200)* %new_stack4, i8 addrspace(200)* addrspace(200)* %args, align 16
  %4 = load float, float addrspace(200)* %3, align 16
  call void @llvm.va_end.p200i8(i8 addrspace(200)* nonnull %0)
  call void @call1(double %2, float %4) #3
  call void @llvm.lifetime.end.p200i8(i64 16, i8 addrspace(200)* nonnull %0) #0
  ret void
}

define i8 addrspace(200)* @test_vacopy(i32 %count, ...) local_unnamed_addr addrspace(200) #0 {
; CHECK-LABEL: test_vacopy:
; CHECK:       .Lfunc_begin5:
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    sub csp, csp, #48
; CHECK-NEXT:    add c0, csp, #32
; CHECK-NEXT:    add c1, csp, #16
; CHECK-NEXT:    scbnds c0, c0, #16 // =16
; CHECK-NEXT:    scbnds c1, c1, #16 // =16
; CHECK-NEXT:    str c9, [csp, #0]
; CHECK-NEXT:    str c9, [c1, #0]
; CHECK-NEXT:    str c9, [c0, #0]
; CHECK-NEXT:    ldr c0, [csp, #32]
; CHECK-NEXT:    add csp, csp, #48
; CHECK-NEXT:    ret c30
entry:
  %retval = alloca i8 addrspace(200)*, align 16, addrspace(200)
  %args = alloca i8 addrspace(200)*, align 16, addrspace(200)
  %0 = bitcast i8 addrspace(200)* addrspace(200)* %args to i8 addrspace(200)*
  call void @llvm.lifetime.start.p200i8(i64 16, i8 addrspace(200)* nonnull %0) #0
  call void @llvm.va_start.p200i8(i8 addrspace(200)* nonnull %0)
  %1 = bitcast i8 addrspace(200)* addrspace(200)* %retval to i8 addrspace(200)*
  call void @llvm.va_copy.p200i8.p200i8(i8 addrspace(200)* nonnull %1, i8 addrspace(200)* nonnull %0)
  call void @llvm.lifetime.end.p200i8(i64 16, i8 addrspace(200)* nonnull %0) #0
  %2 = load i8 addrspace(200)*, i8 addrspace(200)* addrspace(200)* %retval, align 16
  ret i8 addrspace(200)* %2
}

declare void @llvm.va_copy.p200i8.p200i8(i8 addrspace(200)*, i8 addrspace(200)*) addrspace(200) #0

declare void @llvm.va_start.p200i8(i8 addrspace(200)*) addrspace(200) #0

declare void @llvm.va_end.p200i8(i8 addrspace(200)*) addrspace(200) #0

declare void @call1(double, float) local_unnamed_addr addrspace(200) #0

attributes #0 = { nounwind }
