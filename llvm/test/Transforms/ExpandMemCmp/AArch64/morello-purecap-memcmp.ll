; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt -S -expandmemcmp -mtriple=aarch64-none-elf -mattr=+c64,+morello -target-abi purecap < %s | FileCheck %s

declare i32 @memcmp(i8 addrspace(200) * nocapture, i8 addrspace(200) * nocapture, i64)

define i32 @cmp2(i8 addrspace(200) * nocapture readonly %x, i8 addrspace(200) * nocapture readonly %y)  {
; CHECK-LABEL: @cmp2(
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i8 addrspace(200)* [[X:%.*]] to i16 addrspace(200)*
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast i8 addrspace(200)* [[Y:%.*]] to i16 addrspace(200)*
; CHECK-NEXT:    [[TMP3:%.*]] = load i16, i16 addrspace(200)* [[TMP1]]
; CHECK-NEXT:    [[TMP4:%.*]] = load i16, i16 addrspace(200)* [[TMP2]]
; CHECK-NEXT:    [[TMP5:%.*]] = call i16 @llvm.bswap.i16(i16 [[TMP3]])
; CHECK-NEXT:    [[TMP6:%.*]] = call i16 @llvm.bswap.i16(i16 [[TMP4]])
; CHECK-NEXT:    [[TMP7:%.*]] = zext i16 [[TMP5]] to i32
; CHECK-NEXT:    [[TMP8:%.*]] = zext i16 [[TMP6]] to i32
; CHECK-NEXT:    [[TMP9:%.*]] = sub i32 [[TMP7]], [[TMP8]]
; CHECK-NEXT:    ret i32 [[TMP9]]
;
  %call = tail call i32 @memcmp(i8 addrspace(200) * %x, i8 addrspace(200) * %y, i64 2)
  ret i32 %call
}

define i32 @cmp3(i8 addrspace(200) * nocapture readonly %x, i8 addrspace(200) * nocapture readonly %y)  {
; CHECK-LABEL: @cmp3(
; CHECK-NEXT:    br label [[LOADBB:%.*]]
; CHECK:       res_block:
; CHECK-NEXT:    [[TMP1:%.*]] = icmp ult i16 [[TMP7:%.*]], [[TMP8:%.*]]
; CHECK-NEXT:    [[TMP2:%.*]] = select i1 [[TMP1]], i32 -1, i32 1
; CHECK-NEXT:    br label [[ENDBLOCK:%.*]]
; CHECK:       loadbb:
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast i8 addrspace(200)* [[X:%.*]] to i16 addrspace(200)*
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast i8 addrspace(200)* [[Y:%.*]] to i16 addrspace(200)*
; CHECK-NEXT:    [[TMP5:%.*]] = load i16, i16 addrspace(200)* [[TMP3]]
; CHECK-NEXT:    [[TMP6:%.*]] = load i16, i16 addrspace(200)* [[TMP4]]
; CHECK-NEXT:    [[TMP7]] = call i16 @llvm.bswap.i16(i16 [[TMP5]])
; CHECK-NEXT:    [[TMP8]] = call i16 @llvm.bswap.i16(i16 [[TMP6]])
; CHECK-NEXT:    [[TMP9:%.*]] = icmp eq i16 [[TMP7]], [[TMP8]]
; CHECK-NEXT:    br i1 [[TMP9]], label [[LOADBB1:%.*]], label [[RES_BLOCK:%.*]]
; CHECK:       loadbb1:
; CHECK-NEXT:    [[TMP10:%.*]] = getelementptr i8, i8 addrspace(200)* [[X]], i64 2
; CHECK-NEXT:    [[TMP11:%.*]] = getelementptr i8, i8 addrspace(200)* [[Y]], i64 2
; CHECK-NEXT:    [[TMP12:%.*]] = load i8, i8 addrspace(200)* [[TMP10]]
; CHECK-NEXT:    [[TMP13:%.*]] = load i8, i8 addrspace(200)* [[TMP11]]
; CHECK-NEXT:    [[TMP14:%.*]] = zext i8 [[TMP12]] to i32
; CHECK-NEXT:    [[TMP15:%.*]] = zext i8 [[TMP13]] to i32
; CHECK-NEXT:    [[TMP16:%.*]] = sub i32 [[TMP14]], [[TMP15]]
; CHECK-NEXT:    br label [[ENDBLOCK]]
; CHECK:       endblock:
; CHECK-NEXT:    [[PHI_RES:%.*]] = phi i32 [ [[TMP16]], [[LOADBB1]] ], [ [[TMP2]], [[RES_BLOCK]] ]
; CHECK-NEXT:    ret i32 [[PHI_RES]]
;
  %call = tail call i32 @memcmp(i8 addrspace(200) * %x, i8 addrspace(200) * %y, i64 3)
  ret i32 %call
}

define i32 @cmp4(i8 addrspace(200) * nocapture readonly %x, i8 addrspace(200) * nocapture readonly %y)  {
; CHECK-LABEL: @cmp4(
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i8 addrspace(200)* [[X:%.*]] to i32 addrspace(200)*
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast i8 addrspace(200)* [[Y:%.*]] to i32 addrspace(200)*
; CHECK-NEXT:    [[TMP3:%.*]] = load i32, i32 addrspace(200)* [[TMP1]]
; CHECK-NEXT:    [[TMP4:%.*]] = load i32, i32 addrspace(200)* [[TMP2]]
; CHECK-NEXT:    [[TMP5:%.*]] = call i32 @llvm.bswap.i32(i32 [[TMP3]])
; CHECK-NEXT:    [[TMP6:%.*]] = call i32 @llvm.bswap.i32(i32 [[TMP4]])
; CHECK-NEXT:    [[TMP7:%.*]] = icmp ugt i32 [[TMP5]], [[TMP6]]
; CHECK-NEXT:    [[TMP8:%.*]] = icmp ult i32 [[TMP5]], [[TMP6]]
; CHECK-NEXT:    [[TMP9:%.*]] = zext i1 [[TMP7]] to i32
; CHECK-NEXT:    [[TMP10:%.*]] = zext i1 [[TMP8]] to i32
; CHECK-NEXT:    [[TMP11:%.*]] = sub i32 [[TMP9]], [[TMP10]]
; CHECK-NEXT:    ret i32 [[TMP11]]
;
  %call = tail call i32 @memcmp(i8 addrspace(200) * %x, i8 addrspace(200) * %y, i64 4)
  ret i32 %call
}

define i32 @cmp5(i8 addrspace(200) * nocapture readonly %x, i8 addrspace(200) * nocapture readonly %y)  {
; CHECK-LABEL: @cmp5(
; CHECK-NEXT:    br label [[LOADBB:%.*]]
; CHECK:       res_block:
; CHECK-NEXT:    [[TMP1:%.*]] = icmp ult i32 [[TMP7:%.*]], [[TMP8:%.*]]
; CHECK-NEXT:    [[TMP2:%.*]] = select i1 [[TMP1]], i32 -1, i32 1
; CHECK-NEXT:    br label [[ENDBLOCK:%.*]]
; CHECK:       loadbb:
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast i8 addrspace(200)* [[X:%.*]] to i32 addrspace(200)*
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast i8 addrspace(200)* [[Y:%.*]] to i32 addrspace(200)*
; CHECK-NEXT:    [[TMP5:%.*]] = load i32, i32 addrspace(200)* [[TMP3]]
; CHECK-NEXT:    [[TMP6:%.*]] = load i32, i32 addrspace(200)* [[TMP4]]
; CHECK-NEXT:    [[TMP7]] = call i32 @llvm.bswap.i32(i32 [[TMP5]])
; CHECK-NEXT:    [[TMP8]] = call i32 @llvm.bswap.i32(i32 [[TMP6]])
; CHECK-NEXT:    [[TMP9:%.*]] = icmp eq i32 [[TMP7]], [[TMP8]]
; CHECK-NEXT:    br i1 [[TMP9]], label [[LOADBB1:%.*]], label [[RES_BLOCK:%.*]]
; CHECK:       loadbb1:
; CHECK-NEXT:    [[TMP10:%.*]] = getelementptr i8, i8 addrspace(200)* [[X]], i64 4
; CHECK-NEXT:    [[TMP11:%.*]] = getelementptr i8, i8 addrspace(200)* [[Y]], i64 4
; CHECK-NEXT:    [[TMP12:%.*]] = load i8, i8 addrspace(200)* [[TMP10]]
; CHECK-NEXT:    [[TMP13:%.*]] = load i8, i8 addrspace(200)* [[TMP11]]
; CHECK-NEXT:    [[TMP14:%.*]] = zext i8 [[TMP12]] to i32
; CHECK-NEXT:    [[TMP15:%.*]] = zext i8 [[TMP13]] to i32
; CHECK-NEXT:    [[TMP16:%.*]] = sub i32 [[TMP14]], [[TMP15]]
; CHECK-NEXT:    br label [[ENDBLOCK]]
; CHECK:       endblock:
; CHECK-NEXT:    [[PHI_RES:%.*]] = phi i32 [ [[TMP16]], [[LOADBB1]] ], [ [[TMP2]], [[RES_BLOCK]] ]
; CHECK-NEXT:    ret i32 [[PHI_RES]]
;
  %call = tail call i32 @memcmp(i8 addrspace(200) * %x, i8 addrspace(200) * %y, i64 5)
  ret i32 %call
}

define i32 @cmp6(i8 addrspace(200) * nocapture readonly %x, i8 addrspace(200) * nocapture readonly %y)  {
; CHECK-LABEL: @cmp6(
; CHECK-NEXT:    br label [[LOADBB:%.*]]
; CHECK:       res_block:
; CHECK-NEXT:    [[PHI_SRC1:%.*]] = phi i32 [ [[TMP7:%.*]], [[LOADBB]] ], [ [[TMP18:%.*]], [[LOADBB1:%.*]] ]
; CHECK-NEXT:    [[PHI_SRC2:%.*]] = phi i32 [ [[TMP8:%.*]], [[LOADBB]] ], [ [[TMP19:%.*]], [[LOADBB1]] ]
; CHECK-NEXT:    [[TMP1:%.*]] = icmp ult i32 [[PHI_SRC1]], [[PHI_SRC2]]
; CHECK-NEXT:    [[TMP2:%.*]] = select i1 [[TMP1]], i32 -1, i32 1
; CHECK-NEXT:    br label [[ENDBLOCK:%.*]]
; CHECK:       loadbb:
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast i8 addrspace(200)* [[X:%.*]] to i32 addrspace(200)*
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast i8 addrspace(200)* [[Y:%.*]] to i32 addrspace(200)*
; CHECK-NEXT:    [[TMP5:%.*]] = load i32, i32 addrspace(200)* [[TMP3]]
; CHECK-NEXT:    [[TMP6:%.*]] = load i32, i32 addrspace(200)* [[TMP4]]
; CHECK-NEXT:    [[TMP7]] = call i32 @llvm.bswap.i32(i32 [[TMP5]])
; CHECK-NEXT:    [[TMP8]] = call i32 @llvm.bswap.i32(i32 [[TMP6]])
; CHECK-NEXT:    [[TMP9:%.*]] = icmp eq i32 [[TMP7]], [[TMP8]]
; CHECK-NEXT:    br i1 [[TMP9]], label [[LOADBB1]], label [[RES_BLOCK:%.*]]
; CHECK:       loadbb1:
; CHECK-NEXT:    [[TMP10:%.*]] = getelementptr i8, i8 addrspace(200)* [[X]], i64 4
; CHECK-NEXT:    [[TMP11:%.*]] = getelementptr i8, i8 addrspace(200)* [[Y]], i64 4
; CHECK-NEXT:    [[TMP12:%.*]] = bitcast i8 addrspace(200)* [[TMP10]] to i16 addrspace(200)*
; CHECK-NEXT:    [[TMP13:%.*]] = bitcast i8 addrspace(200)* [[TMP11]] to i16 addrspace(200)*
; CHECK-NEXT:    [[TMP14:%.*]] = load i16, i16 addrspace(200)* [[TMP12]]
; CHECK-NEXT:    [[TMP15:%.*]] = load i16, i16 addrspace(200)* [[TMP13]]
; CHECK-NEXT:    [[TMP16:%.*]] = call i16 @llvm.bswap.i16(i16 [[TMP14]])
; CHECK-NEXT:    [[TMP17:%.*]] = call i16 @llvm.bswap.i16(i16 [[TMP15]])
; CHECK-NEXT:    [[TMP18]] = zext i16 [[TMP16]] to i32
; CHECK-NEXT:    [[TMP19]] = zext i16 [[TMP17]] to i32
; CHECK-NEXT:    [[TMP20:%.*]] = icmp eq i32 [[TMP18]], [[TMP19]]
; CHECK-NEXT:    br i1 [[TMP20]], label [[ENDBLOCK]], label [[RES_BLOCK]]
; CHECK:       endblock:
; CHECK-NEXT:    [[PHI_RES:%.*]] = phi i32 [ 0, [[LOADBB1]] ], [ [[TMP2]], [[RES_BLOCK]] ]
; CHECK-NEXT:    ret i32 [[PHI_RES]]
;
  %call = tail call i32 @memcmp(i8 addrspace(200) * %x, i8 addrspace(200) * %y, i64 6)
  ret i32 %call
}

define i32 @cmp7(i8 addrspace(200) * nocapture readonly %x, i8 addrspace(200) * nocapture readonly %y)  {
; CHECK-LABEL: @cmp7(
; CHECK-NEXT:    br label [[LOADBB:%.*]]
; CHECK:       res_block:
; CHECK-NEXT:    [[PHI_SRC1:%.*]] = phi i32 [ [[TMP7:%.*]], [[LOADBB]] ], [ [[TMP16:%.*]], [[LOADBB1:%.*]] ]
; CHECK-NEXT:    [[PHI_SRC2:%.*]] = phi i32 [ [[TMP8:%.*]], [[LOADBB]] ], [ [[TMP17:%.*]], [[LOADBB1]] ]
; CHECK-NEXT:    [[TMP1:%.*]] = icmp ult i32 [[PHI_SRC1]], [[PHI_SRC2]]
; CHECK-NEXT:    [[TMP2:%.*]] = select i1 [[TMP1]], i32 -1, i32 1
; CHECK-NEXT:    br label [[ENDBLOCK:%.*]]
; CHECK:       loadbb:
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast i8 addrspace(200)* [[X:%.*]] to i32 addrspace(200)*
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast i8 addrspace(200)* [[Y:%.*]] to i32 addrspace(200)*
; CHECK-NEXT:    [[TMP5:%.*]] = load i32, i32 addrspace(200)* [[TMP3]]
; CHECK-NEXT:    [[TMP6:%.*]] = load i32, i32 addrspace(200)* [[TMP4]]
; CHECK-NEXT:    [[TMP7]] = call i32 @llvm.bswap.i32(i32 [[TMP5]])
; CHECK-NEXT:    [[TMP8]] = call i32 @llvm.bswap.i32(i32 [[TMP6]])
; CHECK-NEXT:    [[TMP9:%.*]] = icmp eq i32 [[TMP7]], [[TMP8]]
; CHECK-NEXT:    br i1 [[TMP9]], label [[LOADBB1]], label [[RES_BLOCK:%.*]]
; CHECK:       loadbb1:
; CHECK-NEXT:    [[TMP10:%.*]] = getelementptr i8, i8 addrspace(200)* [[X]], i64 3
; CHECK-NEXT:    [[TMP11:%.*]] = getelementptr i8, i8 addrspace(200)* [[Y]], i64 3
; CHECK-NEXT:    [[TMP12:%.*]] = bitcast i8 addrspace(200)* [[TMP10]] to i32 addrspace(200)*
; CHECK-NEXT:    [[TMP13:%.*]] = bitcast i8 addrspace(200)* [[TMP11]] to i32 addrspace(200)*
; CHECK-NEXT:    [[TMP14:%.*]] = load i32, i32 addrspace(200)* [[TMP12]]
; CHECK-NEXT:    [[TMP15:%.*]] = load i32, i32 addrspace(200)* [[TMP13]]
; CHECK-NEXT:    [[TMP16]] = call i32 @llvm.bswap.i32(i32 [[TMP14]])
; CHECK-NEXT:    [[TMP17]] = call i32 @llvm.bswap.i32(i32 [[TMP15]])
; CHECK-NEXT:    [[TMP18:%.*]] = icmp eq i32 [[TMP16]], [[TMP17]]
; CHECK-NEXT:    br i1 [[TMP18]], label [[ENDBLOCK]], label [[RES_BLOCK]]
; CHECK:       endblock:
; CHECK-NEXT:    [[PHI_RES:%.*]] = phi i32 [ 0, [[LOADBB1]] ], [ [[TMP2]], [[RES_BLOCK]] ]
; CHECK-NEXT:    ret i32 [[PHI_RES]]
;
  %call = tail call i32 @memcmp(i8 addrspace(200) * %x, i8 addrspace(200) * %y, i64 7)
  ret i32 %call
}

define i32 @cmp8(i8 addrspace(200) * nocapture readonly %x, i8 addrspace(200) * nocapture readonly %y)  {
; CHECK-LABEL: @cmp8(
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i8 addrspace(200)* [[X:%.*]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast i8 addrspace(200)* [[Y:%.*]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP3:%.*]] = load i64, i64 addrspace(200)* [[TMP1]]
; CHECK-NEXT:    [[TMP4:%.*]] = load i64, i64 addrspace(200)* [[TMP2]]
; CHECK-NEXT:    [[TMP5:%.*]] = call i64 @llvm.bswap.i64(i64 [[TMP3]])
; CHECK-NEXT:    [[TMP6:%.*]] = call i64 @llvm.bswap.i64(i64 [[TMP4]])
; CHECK-NEXT:    [[TMP7:%.*]] = icmp ugt i64 [[TMP5]], [[TMP6]]
; CHECK-NEXT:    [[TMP8:%.*]] = icmp ult i64 [[TMP5]], [[TMP6]]
; CHECK-NEXT:    [[TMP9:%.*]] = zext i1 [[TMP7]] to i32
; CHECK-NEXT:    [[TMP10:%.*]] = zext i1 [[TMP8]] to i32
; CHECK-NEXT:    [[TMP11:%.*]] = sub i32 [[TMP9]], [[TMP10]]
; CHECK-NEXT:    ret i32 [[TMP11]]
;
  %call = tail call i32 @memcmp(i8 addrspace(200) * %x, i8 addrspace(200) * %y, i64 8)
  ret i32 %call
}

define i32 @cmp9(i8 addrspace(200) * nocapture readonly %x, i8 addrspace(200) * nocapture readonly %y)  {
; CHECK-LABEL: @cmp9(
; CHECK-NEXT:    br label [[LOADBB:%.*]]
; CHECK:       res_block:
; CHECK-NEXT:    [[TMP1:%.*]] = icmp ult i64 [[TMP7:%.*]], [[TMP8:%.*]]
; CHECK-NEXT:    [[TMP2:%.*]] = select i1 [[TMP1]], i32 -1, i32 1
; CHECK-NEXT:    br label [[ENDBLOCK:%.*]]
; CHECK:       loadbb:
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast i8 addrspace(200)* [[X:%.*]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast i8 addrspace(200)* [[Y:%.*]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP5:%.*]] = load i64, i64 addrspace(200)* [[TMP3]]
; CHECK-NEXT:    [[TMP6:%.*]] = load i64, i64 addrspace(200)* [[TMP4]]
; CHECK-NEXT:    [[TMP7]] = call i64 @llvm.bswap.i64(i64 [[TMP5]])
; CHECK-NEXT:    [[TMP8]] = call i64 @llvm.bswap.i64(i64 [[TMP6]])
; CHECK-NEXT:    [[TMP9:%.*]] = icmp eq i64 [[TMP7]], [[TMP8]]
; CHECK-NEXT:    br i1 [[TMP9]], label [[LOADBB1:%.*]], label [[RES_BLOCK:%.*]]
; CHECK:       loadbb1:
; CHECK-NEXT:    [[TMP10:%.*]] = getelementptr i8, i8 addrspace(200)* [[X]], i64 8
; CHECK-NEXT:    [[TMP11:%.*]] = getelementptr i8, i8 addrspace(200)* [[Y]], i64 8
; CHECK-NEXT:    [[TMP12:%.*]] = load i8, i8 addrspace(200)* [[TMP10]]
; CHECK-NEXT:    [[TMP13:%.*]] = load i8, i8 addrspace(200)* [[TMP11]]
; CHECK-NEXT:    [[TMP14:%.*]] = zext i8 [[TMP12]] to i32
; CHECK-NEXT:    [[TMP15:%.*]] = zext i8 [[TMP13]] to i32
; CHECK-NEXT:    [[TMP16:%.*]] = sub i32 [[TMP14]], [[TMP15]]
; CHECK-NEXT:    br label [[ENDBLOCK]]
; CHECK:       endblock:
; CHECK-NEXT:    [[PHI_RES:%.*]] = phi i32 [ [[TMP16]], [[LOADBB1]] ], [ [[TMP2]], [[RES_BLOCK]] ]
; CHECK-NEXT:    ret i32 [[PHI_RES]]
;
  %call = tail call i32 @memcmp(i8 addrspace(200) * %x, i8 addrspace(200) * %y, i64 9)
  ret i32 %call
}

define i32 @cmp10(i8 addrspace(200) * nocapture readonly %x, i8 addrspace(200) * nocapture readonly %y)  {
; CHECK-LABEL: @cmp10(
; CHECK-NEXT:    br label [[LOADBB:%.*]]
; CHECK:       res_block:
; CHECK-NEXT:    [[PHI_SRC1:%.*]] = phi i64 [ [[TMP7:%.*]], [[LOADBB]] ], [ [[TMP18:%.*]], [[LOADBB1:%.*]] ]
; CHECK-NEXT:    [[PHI_SRC2:%.*]] = phi i64 [ [[TMP8:%.*]], [[LOADBB]] ], [ [[TMP19:%.*]], [[LOADBB1]] ]
; CHECK-NEXT:    [[TMP1:%.*]] = icmp ult i64 [[PHI_SRC1]], [[PHI_SRC2]]
; CHECK-NEXT:    [[TMP2:%.*]] = select i1 [[TMP1]], i32 -1, i32 1
; CHECK-NEXT:    br label [[ENDBLOCK:%.*]]
; CHECK:       loadbb:
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast i8 addrspace(200)* [[X:%.*]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast i8 addrspace(200)* [[Y:%.*]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP5:%.*]] = load i64, i64 addrspace(200)* [[TMP3]]
; CHECK-NEXT:    [[TMP6:%.*]] = load i64, i64 addrspace(200)* [[TMP4]]
; CHECK-NEXT:    [[TMP7]] = call i64 @llvm.bswap.i64(i64 [[TMP5]])
; CHECK-NEXT:    [[TMP8]] = call i64 @llvm.bswap.i64(i64 [[TMP6]])
; CHECK-NEXT:    [[TMP9:%.*]] = icmp eq i64 [[TMP7]], [[TMP8]]
; CHECK-NEXT:    br i1 [[TMP9]], label [[LOADBB1]], label [[RES_BLOCK:%.*]]
; CHECK:       loadbb1:
; CHECK-NEXT:    [[TMP10:%.*]] = getelementptr i8, i8 addrspace(200)* [[X]], i64 8
; CHECK-NEXT:    [[TMP11:%.*]] = getelementptr i8, i8 addrspace(200)* [[Y]], i64 8
; CHECK-NEXT:    [[TMP12:%.*]] = bitcast i8 addrspace(200)* [[TMP10]] to i16 addrspace(200)*
; CHECK-NEXT:    [[TMP13:%.*]] = bitcast i8 addrspace(200)* [[TMP11]] to i16 addrspace(200)*
; CHECK-NEXT:    [[TMP14:%.*]] = load i16, i16 addrspace(200)* [[TMP12]]
; CHECK-NEXT:    [[TMP15:%.*]] = load i16, i16 addrspace(200)* [[TMP13]]
; CHECK-NEXT:    [[TMP16:%.*]] = call i16 @llvm.bswap.i16(i16 [[TMP14]])
; CHECK-NEXT:    [[TMP17:%.*]] = call i16 @llvm.bswap.i16(i16 [[TMP15]])
; CHECK-NEXT:    [[TMP18]] = zext i16 [[TMP16]] to i64
; CHECK-NEXT:    [[TMP19]] = zext i16 [[TMP17]] to i64
; CHECK-NEXT:    [[TMP20:%.*]] = icmp eq i64 [[TMP18]], [[TMP19]]
; CHECK-NEXT:    br i1 [[TMP20]], label [[ENDBLOCK]], label [[RES_BLOCK]]
; CHECK:       endblock:
; CHECK-NEXT:    [[PHI_RES:%.*]] = phi i32 [ 0, [[LOADBB1]] ], [ [[TMP2]], [[RES_BLOCK]] ]
; CHECK-NEXT:    ret i32 [[PHI_RES]]
;
  %call = tail call i32 @memcmp(i8 addrspace(200) * %x, i8 addrspace(200) * %y, i64 10)
  ret i32 %call
}

define i32 @cmp11(i8 addrspace(200) * nocapture readonly %x, i8 addrspace(200) * nocapture readonly %y)  {
; CHECK-LABEL: @cmp11(
; CHECK-NEXT:    br label [[LOADBB:%.*]]
; CHECK:       res_block:
; CHECK-NEXT:    [[PHI_SRC1:%.*]] = phi i64 [ [[TMP7:%.*]], [[LOADBB]] ], [ [[TMP16:%.*]], [[LOADBB1:%.*]] ]
; CHECK-NEXT:    [[PHI_SRC2:%.*]] = phi i64 [ [[TMP8:%.*]], [[LOADBB]] ], [ [[TMP17:%.*]], [[LOADBB1]] ]
; CHECK-NEXT:    [[TMP1:%.*]] = icmp ult i64 [[PHI_SRC1]], [[PHI_SRC2]]
; CHECK-NEXT:    [[TMP2:%.*]] = select i1 [[TMP1]], i32 -1, i32 1
; CHECK-NEXT:    br label [[ENDBLOCK:%.*]]
; CHECK:       loadbb:
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast i8 addrspace(200)* [[X:%.*]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast i8 addrspace(200)* [[Y:%.*]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP5:%.*]] = load i64, i64 addrspace(200)* [[TMP3]]
; CHECK-NEXT:    [[TMP6:%.*]] = load i64, i64 addrspace(200)* [[TMP4]]
; CHECK-NEXT:    [[TMP7]] = call i64 @llvm.bswap.i64(i64 [[TMP5]])
; CHECK-NEXT:    [[TMP8]] = call i64 @llvm.bswap.i64(i64 [[TMP6]])
; CHECK-NEXT:    [[TMP9:%.*]] = icmp eq i64 [[TMP7]], [[TMP8]]
; CHECK-NEXT:    br i1 [[TMP9]], label [[LOADBB1]], label [[RES_BLOCK:%.*]]
; CHECK:       loadbb1:
; CHECK-NEXT:    [[TMP10:%.*]] = getelementptr i8, i8 addrspace(200)* [[X]], i64 3
; CHECK-NEXT:    [[TMP11:%.*]] = getelementptr i8, i8 addrspace(200)* [[Y]], i64 3
; CHECK-NEXT:    [[TMP12:%.*]] = bitcast i8 addrspace(200)* [[TMP10]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP13:%.*]] = bitcast i8 addrspace(200)* [[TMP11]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP14:%.*]] = load i64, i64 addrspace(200)* [[TMP12]]
; CHECK-NEXT:    [[TMP15:%.*]] = load i64, i64 addrspace(200)* [[TMP13]]
; CHECK-NEXT:    [[TMP16]] = call i64 @llvm.bswap.i64(i64 [[TMP14]])
; CHECK-NEXT:    [[TMP17]] = call i64 @llvm.bswap.i64(i64 [[TMP15]])
; CHECK-NEXT:    [[TMP18:%.*]] = icmp eq i64 [[TMP16]], [[TMP17]]
; CHECK-NEXT:    br i1 [[TMP18]], label [[ENDBLOCK]], label [[RES_BLOCK]]
; CHECK:       endblock:
; CHECK-NEXT:    [[PHI_RES:%.*]] = phi i32 [ 0, [[LOADBB1]] ], [ [[TMP2]], [[RES_BLOCK]] ]
; CHECK-NEXT:    ret i32 [[PHI_RES]]
;
  %call = tail call i32 @memcmp(i8 addrspace(200) * %x, i8 addrspace(200) * %y, i64 11)
  ret i32 %call
}

define i32 @cmp12(i8 addrspace(200) * nocapture readonly %x, i8 addrspace(200) * nocapture readonly %y)  {
; CHECK-LABEL: @cmp12(
; CHECK-NEXT:    br label [[LOADBB:%.*]]
; CHECK:       res_block:
; CHECK-NEXT:    [[PHI_SRC1:%.*]] = phi i64 [ [[TMP7:%.*]], [[LOADBB]] ], [ [[TMP18:%.*]], [[LOADBB1:%.*]] ]
; CHECK-NEXT:    [[PHI_SRC2:%.*]] = phi i64 [ [[TMP8:%.*]], [[LOADBB]] ], [ [[TMP19:%.*]], [[LOADBB1]] ]
; CHECK-NEXT:    [[TMP1:%.*]] = icmp ult i64 [[PHI_SRC1]], [[PHI_SRC2]]
; CHECK-NEXT:    [[TMP2:%.*]] = select i1 [[TMP1]], i32 -1, i32 1
; CHECK-NEXT:    br label [[ENDBLOCK:%.*]]
; CHECK:       loadbb:
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast i8 addrspace(200)* [[X:%.*]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast i8 addrspace(200)* [[Y:%.*]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP5:%.*]] = load i64, i64 addrspace(200)* [[TMP3]]
; CHECK-NEXT:    [[TMP6:%.*]] = load i64, i64 addrspace(200)* [[TMP4]]
; CHECK-NEXT:    [[TMP7]] = call i64 @llvm.bswap.i64(i64 [[TMP5]])
; CHECK-NEXT:    [[TMP8]] = call i64 @llvm.bswap.i64(i64 [[TMP6]])
; CHECK-NEXT:    [[TMP9:%.*]] = icmp eq i64 [[TMP7]], [[TMP8]]
; CHECK-NEXT:    br i1 [[TMP9]], label [[LOADBB1]], label [[RES_BLOCK:%.*]]
; CHECK:       loadbb1:
; CHECK-NEXT:    [[TMP10:%.*]] = getelementptr i8, i8 addrspace(200)* [[X]], i64 8
; CHECK-NEXT:    [[TMP11:%.*]] = getelementptr i8, i8 addrspace(200)* [[Y]], i64 8
; CHECK-NEXT:    [[TMP12:%.*]] = bitcast i8 addrspace(200)* [[TMP10]] to i32 addrspace(200)*
; CHECK-NEXT:    [[TMP13:%.*]] = bitcast i8 addrspace(200)* [[TMP11]] to i32 addrspace(200)*
; CHECK-NEXT:    [[TMP14:%.*]] = load i32, i32 addrspace(200)* [[TMP12]]
; CHECK-NEXT:    [[TMP15:%.*]] = load i32, i32 addrspace(200)* [[TMP13]]
; CHECK-NEXT:    [[TMP16:%.*]] = call i32 @llvm.bswap.i32(i32 [[TMP14]])
; CHECK-NEXT:    [[TMP17:%.*]] = call i32 @llvm.bswap.i32(i32 [[TMP15]])
; CHECK-NEXT:    [[TMP18]] = zext i32 [[TMP16]] to i64
; CHECK-NEXT:    [[TMP19]] = zext i32 [[TMP17]] to i64
; CHECK-NEXT:    [[TMP20:%.*]] = icmp eq i64 [[TMP18]], [[TMP19]]
; CHECK-NEXT:    br i1 [[TMP20]], label [[ENDBLOCK]], label [[RES_BLOCK]]
; CHECK:       endblock:
; CHECK-NEXT:    [[PHI_RES:%.*]] = phi i32 [ 0, [[LOADBB1]] ], [ [[TMP2]], [[RES_BLOCK]] ]
; CHECK-NEXT:    ret i32 [[PHI_RES]]
;
  %call = tail call i32 @memcmp(i8 addrspace(200) * %x, i8 addrspace(200) * %y, i64 12)
  ret i32 %call
}

define i32 @cmp13(i8 addrspace(200) * nocapture readonly %x, i8 addrspace(200) * nocapture readonly %y)  {
; CHECK-LABEL: @cmp13(
; CHECK-NEXT:    br label [[LOADBB:%.*]]
; CHECK:       res_block:
; CHECK-NEXT:    [[PHI_SRC1:%.*]] = phi i64 [ [[TMP7:%.*]], [[LOADBB]] ], [ [[TMP16:%.*]], [[LOADBB1:%.*]] ]
; CHECK-NEXT:    [[PHI_SRC2:%.*]] = phi i64 [ [[TMP8:%.*]], [[LOADBB]] ], [ [[TMP17:%.*]], [[LOADBB1]] ]
; CHECK-NEXT:    [[TMP1:%.*]] = icmp ult i64 [[PHI_SRC1]], [[PHI_SRC2]]
; CHECK-NEXT:    [[TMP2:%.*]] = select i1 [[TMP1]], i32 -1, i32 1
; CHECK-NEXT:    br label [[ENDBLOCK:%.*]]
; CHECK:       loadbb:
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast i8 addrspace(200)* [[X:%.*]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast i8 addrspace(200)* [[Y:%.*]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP5:%.*]] = load i64, i64 addrspace(200)* [[TMP3]]
; CHECK-NEXT:    [[TMP6:%.*]] = load i64, i64 addrspace(200)* [[TMP4]]
; CHECK-NEXT:    [[TMP7]] = call i64 @llvm.bswap.i64(i64 [[TMP5]])
; CHECK-NEXT:    [[TMP8]] = call i64 @llvm.bswap.i64(i64 [[TMP6]])
; CHECK-NEXT:    [[TMP9:%.*]] = icmp eq i64 [[TMP7]], [[TMP8]]
; CHECK-NEXT:    br i1 [[TMP9]], label [[LOADBB1]], label [[RES_BLOCK:%.*]]
; CHECK:       loadbb1:
; CHECK-NEXT:    [[TMP10:%.*]] = getelementptr i8, i8 addrspace(200)* [[X]], i64 5
; CHECK-NEXT:    [[TMP11:%.*]] = getelementptr i8, i8 addrspace(200)* [[Y]], i64 5
; CHECK-NEXT:    [[TMP12:%.*]] = bitcast i8 addrspace(200)* [[TMP10]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP13:%.*]] = bitcast i8 addrspace(200)* [[TMP11]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP14:%.*]] = load i64, i64 addrspace(200)* [[TMP12]]
; CHECK-NEXT:    [[TMP15:%.*]] = load i64, i64 addrspace(200)* [[TMP13]]
; CHECK-NEXT:    [[TMP16]] = call i64 @llvm.bswap.i64(i64 [[TMP14]])
; CHECK-NEXT:    [[TMP17]] = call i64 @llvm.bswap.i64(i64 [[TMP15]])
; CHECK-NEXT:    [[TMP18:%.*]] = icmp eq i64 [[TMP16]], [[TMP17]]
; CHECK-NEXT:    br i1 [[TMP18]], label [[ENDBLOCK]], label [[RES_BLOCK]]
; CHECK:       endblock:
; CHECK-NEXT:    [[PHI_RES:%.*]] = phi i32 [ 0, [[LOADBB1]] ], [ [[TMP2]], [[RES_BLOCK]] ]
; CHECK-NEXT:    ret i32 [[PHI_RES]]
;
  %call = tail call i32 @memcmp(i8 addrspace(200) * %x, i8 addrspace(200) * %y, i64 13)
  ret i32 %call
}

define i32 @cmp14(i8 addrspace(200) * nocapture readonly %x, i8 addrspace(200) * nocapture readonly %y)  {
; CHECK-LABEL: @cmp14(
; CHECK-NEXT:    br label [[LOADBB:%.*]]
; CHECK:       res_block:
; CHECK-NEXT:    [[PHI_SRC1:%.*]] = phi i64 [ [[TMP7:%.*]], [[LOADBB]] ], [ [[TMP16:%.*]], [[LOADBB1:%.*]] ]
; CHECK-NEXT:    [[PHI_SRC2:%.*]] = phi i64 [ [[TMP8:%.*]], [[LOADBB]] ], [ [[TMP17:%.*]], [[LOADBB1]] ]
; CHECK-NEXT:    [[TMP1:%.*]] = icmp ult i64 [[PHI_SRC1]], [[PHI_SRC2]]
; CHECK-NEXT:    [[TMP2:%.*]] = select i1 [[TMP1]], i32 -1, i32 1
; CHECK-NEXT:    br label [[ENDBLOCK:%.*]]
; CHECK:       loadbb:
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast i8 addrspace(200)* [[X:%.*]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast i8 addrspace(200)* [[Y:%.*]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP5:%.*]] = load i64, i64 addrspace(200)* [[TMP3]]
; CHECK-NEXT:    [[TMP6:%.*]] = load i64, i64 addrspace(200)* [[TMP4]]
; CHECK-NEXT:    [[TMP7]] = call i64 @llvm.bswap.i64(i64 [[TMP5]])
; CHECK-NEXT:    [[TMP8]] = call i64 @llvm.bswap.i64(i64 [[TMP6]])
; CHECK-NEXT:    [[TMP9:%.*]] = icmp eq i64 [[TMP7]], [[TMP8]]
; CHECK-NEXT:    br i1 [[TMP9]], label [[LOADBB1]], label [[RES_BLOCK:%.*]]
; CHECK:       loadbb1:
; CHECK-NEXT:    [[TMP10:%.*]] = getelementptr i8, i8 addrspace(200)* [[X]], i64 6
; CHECK-NEXT:    [[TMP11:%.*]] = getelementptr i8, i8 addrspace(200)* [[Y]], i64 6
; CHECK-NEXT:    [[TMP12:%.*]] = bitcast i8 addrspace(200)* [[TMP10]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP13:%.*]] = bitcast i8 addrspace(200)* [[TMP11]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP14:%.*]] = load i64, i64 addrspace(200)* [[TMP12]]
; CHECK-NEXT:    [[TMP15:%.*]] = load i64, i64 addrspace(200)* [[TMP13]]
; CHECK-NEXT:    [[TMP16]] = call i64 @llvm.bswap.i64(i64 [[TMP14]])
; CHECK-NEXT:    [[TMP17]] = call i64 @llvm.bswap.i64(i64 [[TMP15]])
; CHECK-NEXT:    [[TMP18:%.*]] = icmp eq i64 [[TMP16]], [[TMP17]]
; CHECK-NEXT:    br i1 [[TMP18]], label [[ENDBLOCK]], label [[RES_BLOCK]]
; CHECK:       endblock:
; CHECK-NEXT:    [[PHI_RES:%.*]] = phi i32 [ 0, [[LOADBB1]] ], [ [[TMP2]], [[RES_BLOCK]] ]
; CHECK-NEXT:    ret i32 [[PHI_RES]]
;
  %call = tail call i32 @memcmp(i8 addrspace(200) * %x, i8 addrspace(200) * %y, i64 14)
  ret i32 %call
}

define i32 @cmp15(i8 addrspace(200) * nocapture readonly %x, i8 addrspace(200) * nocapture readonly %y)  {
; CHECK-LABEL: @cmp15(
; CHECK-NEXT:    br label [[LOADBB:%.*]]
; CHECK:       res_block:
; CHECK-NEXT:    [[PHI_SRC1:%.*]] = phi i64 [ [[TMP7:%.*]], [[LOADBB]] ], [ [[TMP16:%.*]], [[LOADBB1:%.*]] ]
; CHECK-NEXT:    [[PHI_SRC2:%.*]] = phi i64 [ [[TMP8:%.*]], [[LOADBB]] ], [ [[TMP17:%.*]], [[LOADBB1]] ]
; CHECK-NEXT:    [[TMP1:%.*]] = icmp ult i64 [[PHI_SRC1]], [[PHI_SRC2]]
; CHECK-NEXT:    [[TMP2:%.*]] = select i1 [[TMP1]], i32 -1, i32 1
; CHECK-NEXT:    br label [[ENDBLOCK:%.*]]
; CHECK:       loadbb:
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast i8 addrspace(200)* [[X:%.*]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast i8 addrspace(200)* [[Y:%.*]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP5:%.*]] = load i64, i64 addrspace(200)* [[TMP3]]
; CHECK-NEXT:    [[TMP6:%.*]] = load i64, i64 addrspace(200)* [[TMP4]]
; CHECK-NEXT:    [[TMP7]] = call i64 @llvm.bswap.i64(i64 [[TMP5]])
; CHECK-NEXT:    [[TMP8]] = call i64 @llvm.bswap.i64(i64 [[TMP6]])
; CHECK-NEXT:    [[TMP9:%.*]] = icmp eq i64 [[TMP7]], [[TMP8]]
; CHECK-NEXT:    br i1 [[TMP9]], label [[LOADBB1]], label [[RES_BLOCK:%.*]]
; CHECK:       loadbb1:
; CHECK-NEXT:    [[TMP10:%.*]] = getelementptr i8, i8 addrspace(200)* [[X]], i64 7
; CHECK-NEXT:    [[TMP11:%.*]] = getelementptr i8, i8 addrspace(200)* [[Y]], i64 7
; CHECK-NEXT:    [[TMP12:%.*]] = bitcast i8 addrspace(200)* [[TMP10]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP13:%.*]] = bitcast i8 addrspace(200)* [[TMP11]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP14:%.*]] = load i64, i64 addrspace(200)* [[TMP12]]
; CHECK-NEXT:    [[TMP15:%.*]] = load i64, i64 addrspace(200)* [[TMP13]]
; CHECK-NEXT:    [[TMP16]] = call i64 @llvm.bswap.i64(i64 [[TMP14]])
; CHECK-NEXT:    [[TMP17]] = call i64 @llvm.bswap.i64(i64 [[TMP15]])
; CHECK-NEXT:    [[TMP18:%.*]] = icmp eq i64 [[TMP16]], [[TMP17]]
; CHECK-NEXT:    br i1 [[TMP18]], label [[ENDBLOCK]], label [[RES_BLOCK]]
; CHECK:       endblock:
; CHECK-NEXT:    [[PHI_RES:%.*]] = phi i32 [ 0, [[LOADBB1]] ], [ [[TMP2]], [[RES_BLOCK]] ]
; CHECK-NEXT:    ret i32 [[PHI_RES]]
;
  %call = tail call i32 @memcmp(i8 addrspace(200) * %x, i8 addrspace(200) * %y, i64 15)
  ret i32 %call
}

define i32 @cmp16(i8 addrspace(200) * nocapture readonly %x, i8 addrspace(200) * nocapture readonly %y)  {
; CHECK-LABEL: @cmp16(
; CHECK-NEXT:    br label [[LOADBB:%.*]]
; CHECK:       res_block:
; CHECK-NEXT:    [[PHI_SRC1:%.*]] = phi i64 [ [[TMP7:%.*]], [[LOADBB]] ], [ [[TMP16:%.*]], [[LOADBB1:%.*]] ]
; CHECK-NEXT:    [[PHI_SRC2:%.*]] = phi i64 [ [[TMP8:%.*]], [[LOADBB]] ], [ [[TMP17:%.*]], [[LOADBB1]] ]
; CHECK-NEXT:    [[TMP1:%.*]] = icmp ult i64 [[PHI_SRC1]], [[PHI_SRC2]]
; CHECK-NEXT:    [[TMP2:%.*]] = select i1 [[TMP1]], i32 -1, i32 1
; CHECK-NEXT:    br label [[ENDBLOCK:%.*]]
; CHECK:       loadbb:
; CHECK-NEXT:    [[TMP3:%.*]] = bitcast i8 addrspace(200)* [[X:%.*]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP4:%.*]] = bitcast i8 addrspace(200)* [[Y:%.*]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP5:%.*]] = load i64, i64 addrspace(200)* [[TMP3]]
; CHECK-NEXT:    [[TMP6:%.*]] = load i64, i64 addrspace(200)* [[TMP4]]
; CHECK-NEXT:    [[TMP7]] = call i64 @llvm.bswap.i64(i64 [[TMP5]])
; CHECK-NEXT:    [[TMP8]] = call i64 @llvm.bswap.i64(i64 [[TMP6]])
; CHECK-NEXT:    [[TMP9:%.*]] = icmp eq i64 [[TMP7]], [[TMP8]]
; CHECK-NEXT:    br i1 [[TMP9]], label [[LOADBB1]], label [[RES_BLOCK:%.*]]
; CHECK:       loadbb1:
; CHECK-NEXT:    [[TMP10:%.*]] = getelementptr i8, i8 addrspace(200)* [[X]], i64 8
; CHECK-NEXT:    [[TMP11:%.*]] = getelementptr i8, i8 addrspace(200)* [[Y]], i64 8
; CHECK-NEXT:    [[TMP12:%.*]] = bitcast i8 addrspace(200)* [[TMP10]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP13:%.*]] = bitcast i8 addrspace(200)* [[TMP11]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP14:%.*]] = load i64, i64 addrspace(200)* [[TMP12]]
; CHECK-NEXT:    [[TMP15:%.*]] = load i64, i64 addrspace(200)* [[TMP13]]
; CHECK-NEXT:    [[TMP16]] = call i64 @llvm.bswap.i64(i64 [[TMP14]])
; CHECK-NEXT:    [[TMP17]] = call i64 @llvm.bswap.i64(i64 [[TMP15]])
; CHECK-NEXT:    [[TMP18:%.*]] = icmp eq i64 [[TMP16]], [[TMP17]]
; CHECK-NEXT:    br i1 [[TMP18]], label [[ENDBLOCK]], label [[RES_BLOCK]]
; CHECK:       endblock:
; CHECK-NEXT:    [[PHI_RES:%.*]] = phi i32 [ 0, [[LOADBB1]] ], [ [[TMP2]], [[RES_BLOCK]] ]
; CHECK-NEXT:    ret i32 [[PHI_RES]]
;
  %call = tail call i32 @memcmp(i8 addrspace(200) * %x, i8 addrspace(200) * %y, i64 16)
  ret i32 %call
}

define i32 @cmp_eq2(i8 addrspace(200) * nocapture readonly %x, i8 addrspace(200) * nocapture readonly %y)  {
; CHECK-LABEL: @cmp_eq2(
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i8 addrspace(200)* [[X:%.*]] to i16 addrspace(200)*
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast i8 addrspace(200)* [[Y:%.*]] to i16 addrspace(200)*
; CHECK-NEXT:    [[TMP3:%.*]] = load i16, i16 addrspace(200)* [[TMP1]]
; CHECK-NEXT:    [[TMP4:%.*]] = load i16, i16 addrspace(200)* [[TMP2]]
; CHECK-NEXT:    [[TMP5:%.*]] = icmp ne i16 [[TMP3]], [[TMP4]]
; CHECK-NEXT:    [[TMP6:%.*]] = zext i1 [[TMP5]] to i32
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[TMP6]], 0
; CHECK-NEXT:    [[CONV:%.*]] = zext i1 [[CMP]] to i32
; CHECK-NEXT:    ret i32 [[CONV]]
;
  %call = tail call i32 @memcmp(i8 addrspace(200) * %x, i8 addrspace(200) * %y, i64 2)
  %cmp = icmp eq i32 %call, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

define i32 @cmp_eq3(i8 addrspace(200) * nocapture readonly %x, i8 addrspace(200) * nocapture readonly %y)  {
; CHECK-LABEL: @cmp_eq3(
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i8 addrspace(200)* [[X:%.*]] to i16 addrspace(200)*
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast i8 addrspace(200)* [[Y:%.*]] to i16 addrspace(200)*
; CHECK-NEXT:    [[TMP3:%.*]] = load i16, i16 addrspace(200)* [[TMP1]]
; CHECK-NEXT:    [[TMP4:%.*]] = load i16, i16 addrspace(200)* [[TMP2]]
; CHECK-NEXT:    [[TMP5:%.*]] = xor i16 [[TMP3]], [[TMP4]]
; CHECK-NEXT:    [[TMP6:%.*]] = getelementptr i8, i8 addrspace(200)* [[X]], i64 2
; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr i8, i8 addrspace(200)* [[Y]], i64 2
; CHECK-NEXT:    [[TMP8:%.*]] = load i8, i8 addrspace(200)* [[TMP6]]
; CHECK-NEXT:    [[TMP9:%.*]] = load i8, i8 addrspace(200)* [[TMP7]]
; CHECK-NEXT:    [[TMP10:%.*]] = zext i8 [[TMP8]] to i16
; CHECK-NEXT:    [[TMP11:%.*]] = zext i8 [[TMP9]] to i16
; CHECK-NEXT:    [[TMP12:%.*]] = xor i16 [[TMP10]], [[TMP11]]
; CHECK-NEXT:    [[TMP13:%.*]] = or i16 [[TMP5]], [[TMP12]]
; CHECK-NEXT:    [[TMP14:%.*]] = icmp ne i16 [[TMP13]], 0
; CHECK-NEXT:    [[TMP15:%.*]] = zext i1 [[TMP14]] to i32
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[TMP15]], 0
; CHECK-NEXT:    [[CONV:%.*]] = zext i1 [[CMP]] to i32
; CHECK-NEXT:    ret i32 [[CONV]]
;
  %call = tail call i32 @memcmp(i8 addrspace(200) * %x, i8 addrspace(200) * %y, i64 3)
  %cmp = icmp eq i32 %call, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

define i32 @cmp_eq4(i8 addrspace(200) * nocapture readonly %x, i8 addrspace(200) * nocapture readonly %y)  {
; CHECK-LABEL: @cmp_eq4(
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i8 addrspace(200)* [[X:%.*]] to i32 addrspace(200)*
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast i8 addrspace(200)* [[Y:%.*]] to i32 addrspace(200)*
; CHECK-NEXT:    [[TMP3:%.*]] = load i32, i32 addrspace(200)* [[TMP1]]
; CHECK-NEXT:    [[TMP4:%.*]] = load i32, i32 addrspace(200)* [[TMP2]]
; CHECK-NEXT:    [[TMP5:%.*]] = icmp ne i32 [[TMP3]], [[TMP4]]
; CHECK-NEXT:    [[TMP6:%.*]] = zext i1 [[TMP5]] to i32
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[TMP6]], 0
; CHECK-NEXT:    [[CONV:%.*]] = zext i1 [[CMP]] to i32
; CHECK-NEXT:    ret i32 [[CONV]]
;
  %call = tail call i32 @memcmp(i8 addrspace(200) * %x, i8 addrspace(200) * %y, i64 4)
  %cmp = icmp eq i32 %call, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

define i32 @cmp_eq5(i8 addrspace(200) * nocapture readonly %x, i8 addrspace(200) * nocapture readonly %y)  {
; CHECK-LABEL: @cmp_eq5(
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i8 addrspace(200)* [[X:%.*]] to i32 addrspace(200)*
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast i8 addrspace(200)* [[Y:%.*]] to i32 addrspace(200)*
; CHECK-NEXT:    [[TMP3:%.*]] = load i32, i32 addrspace(200)* [[TMP1]]
; CHECK-NEXT:    [[TMP4:%.*]] = load i32, i32 addrspace(200)* [[TMP2]]
; CHECK-NEXT:    [[TMP5:%.*]] = xor i32 [[TMP3]], [[TMP4]]
; CHECK-NEXT:    [[TMP6:%.*]] = getelementptr i8, i8 addrspace(200)* [[X]], i64 4
; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr i8, i8 addrspace(200)* [[Y]], i64 4
; CHECK-NEXT:    [[TMP8:%.*]] = load i8, i8 addrspace(200)* [[TMP6]]
; CHECK-NEXT:    [[TMP9:%.*]] = load i8, i8 addrspace(200)* [[TMP7]]
; CHECK-NEXT:    [[TMP10:%.*]] = zext i8 [[TMP8]] to i32
; CHECK-NEXT:    [[TMP11:%.*]] = zext i8 [[TMP9]] to i32
; CHECK-NEXT:    [[TMP12:%.*]] = xor i32 [[TMP10]], [[TMP11]]
; CHECK-NEXT:    [[TMP13:%.*]] = or i32 [[TMP5]], [[TMP12]]
; CHECK-NEXT:    [[TMP14:%.*]] = icmp ne i32 [[TMP13]], 0
; CHECK-NEXT:    [[TMP15:%.*]] = zext i1 [[TMP14]] to i32
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[TMP15]], 0
; CHECK-NEXT:    [[CONV:%.*]] = zext i1 [[CMP]] to i32
; CHECK-NEXT:    ret i32 [[CONV]]
;
  %call = tail call i32 @memcmp(i8 addrspace(200) * %x, i8 addrspace(200) * %y, i64 5)
  %cmp = icmp eq i32 %call, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

define i32 @cmp_eq6(i8 addrspace(200) * nocapture readonly %x, i8 addrspace(200) * nocapture readonly %y)  {
; CHECK-LABEL: @cmp_eq6(
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i8 addrspace(200)* [[X:%.*]] to i32 addrspace(200)*
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast i8 addrspace(200)* [[Y:%.*]] to i32 addrspace(200)*
; CHECK-NEXT:    [[TMP3:%.*]] = load i32, i32 addrspace(200)* [[TMP1]]
; CHECK-NEXT:    [[TMP4:%.*]] = load i32, i32 addrspace(200)* [[TMP2]]
; CHECK-NEXT:    [[TMP5:%.*]] = xor i32 [[TMP3]], [[TMP4]]
; CHECK-NEXT:    [[TMP6:%.*]] = getelementptr i8, i8 addrspace(200)* [[X]], i64 4
; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr i8, i8 addrspace(200)* [[Y]], i64 4
; CHECK-NEXT:    [[TMP8:%.*]] = bitcast i8 addrspace(200)* [[TMP6]] to i16 addrspace(200)*
; CHECK-NEXT:    [[TMP9:%.*]] = bitcast i8 addrspace(200)* [[TMP7]] to i16 addrspace(200)*
; CHECK-NEXT:    [[TMP10:%.*]] = load i16, i16 addrspace(200)* [[TMP8]]
; CHECK-NEXT:    [[TMP11:%.*]] = load i16, i16 addrspace(200)* [[TMP9]]
; CHECK-NEXT:    [[TMP12:%.*]] = zext i16 [[TMP10]] to i32
; CHECK-NEXT:    [[TMP13:%.*]] = zext i16 [[TMP11]] to i32
; CHECK-NEXT:    [[TMP14:%.*]] = xor i32 [[TMP12]], [[TMP13]]
; CHECK-NEXT:    [[TMP15:%.*]] = or i32 [[TMP5]], [[TMP14]]
; CHECK-NEXT:    [[TMP16:%.*]] = icmp ne i32 [[TMP15]], 0
; CHECK-NEXT:    [[TMP17:%.*]] = zext i1 [[TMP16]] to i32
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[TMP17]], 0
; CHECK-NEXT:    [[CONV:%.*]] = zext i1 [[CMP]] to i32
; CHECK-NEXT:    ret i32 [[CONV]]
;
  %call = tail call i32 @memcmp(i8 addrspace(200) * %x, i8 addrspace(200) * %y, i64 6)
  %cmp = icmp eq i32 %call, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

define i32 @cmp_eq7(i8 addrspace(200) * nocapture readonly %x, i8 addrspace(200) * nocapture readonly %y)  {
; CHECK-LABEL: @cmp_eq7(
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i8 addrspace(200)* [[X:%.*]] to i32 addrspace(200)*
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast i8 addrspace(200)* [[Y:%.*]] to i32 addrspace(200)*
; CHECK-NEXT:    [[TMP3:%.*]] = load i32, i32 addrspace(200)* [[TMP1]]
; CHECK-NEXT:    [[TMP4:%.*]] = load i32, i32 addrspace(200)* [[TMP2]]
; CHECK-NEXT:    [[TMP5:%.*]] = xor i32 [[TMP3]], [[TMP4]]
; CHECK-NEXT:    [[TMP6:%.*]] = getelementptr i8, i8 addrspace(200)* [[X]], i64 3
; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr i8, i8 addrspace(200)* [[Y]], i64 3
; CHECK-NEXT:    [[TMP8:%.*]] = bitcast i8 addrspace(200)* [[TMP6]] to i32 addrspace(200)*
; CHECK-NEXT:    [[TMP9:%.*]] = bitcast i8 addrspace(200)* [[TMP7]] to i32 addrspace(200)*
; CHECK-NEXT:    [[TMP10:%.*]] = load i32, i32 addrspace(200)* [[TMP8]]
; CHECK-NEXT:    [[TMP11:%.*]] = load i32, i32 addrspace(200)* [[TMP9]]
; CHECK-NEXT:    [[TMP12:%.*]] = xor i32 [[TMP10]], [[TMP11]]
; CHECK-NEXT:    [[TMP13:%.*]] = or i32 [[TMP5]], [[TMP12]]
; CHECK-NEXT:    [[TMP14:%.*]] = icmp ne i32 [[TMP13]], 0
; CHECK-NEXT:    [[TMP15:%.*]] = zext i1 [[TMP14]] to i32
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[TMP15]], 0
; CHECK-NEXT:    [[CONV:%.*]] = zext i1 [[CMP]] to i32
; CHECK-NEXT:    ret i32 [[CONV]]
;
  %call = tail call i32 @memcmp(i8 addrspace(200) * %x, i8 addrspace(200) * %y, i64 7)
  %cmp = icmp eq i32 %call, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

define i32 @cmp_eq8(i8 addrspace(200) * nocapture readonly %x, i8 addrspace(200) * nocapture readonly %y)  {
; CHECK-LABEL: @cmp_eq8(
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i8 addrspace(200)* [[X:%.*]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast i8 addrspace(200)* [[Y:%.*]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP3:%.*]] = load i64, i64 addrspace(200)* [[TMP1]]
; CHECK-NEXT:    [[TMP4:%.*]] = load i64, i64 addrspace(200)* [[TMP2]]
; CHECK-NEXT:    [[TMP5:%.*]] = icmp ne i64 [[TMP3]], [[TMP4]]
; CHECK-NEXT:    [[TMP6:%.*]] = zext i1 [[TMP5]] to i32
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[TMP6]], 0
; CHECK-NEXT:    [[CONV:%.*]] = zext i1 [[CMP]] to i32
; CHECK-NEXT:    ret i32 [[CONV]]
;
  %call = tail call i32 @memcmp(i8 addrspace(200) * %x, i8 addrspace(200) * %y, i64 8)
  %cmp = icmp eq i32 %call, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

define i32 @cmp_eq9(i8 addrspace(200) * nocapture readonly %x, i8 addrspace(200) * nocapture readonly %y)  {
; CHECK-LABEL: @cmp_eq9(
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i8 addrspace(200)* [[X:%.*]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast i8 addrspace(200)* [[Y:%.*]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP3:%.*]] = load i64, i64 addrspace(200)* [[TMP1]]
; CHECK-NEXT:    [[TMP4:%.*]] = load i64, i64 addrspace(200)* [[TMP2]]
; CHECK-NEXT:    [[TMP5:%.*]] = xor i64 [[TMP3]], [[TMP4]]
; CHECK-NEXT:    [[TMP6:%.*]] = getelementptr i8, i8 addrspace(200)* [[X]], i64 8
; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr i8, i8 addrspace(200)* [[Y]], i64 8
; CHECK-NEXT:    [[TMP8:%.*]] = load i8, i8 addrspace(200)* [[TMP6]]
; CHECK-NEXT:    [[TMP9:%.*]] = load i8, i8 addrspace(200)* [[TMP7]]
; CHECK-NEXT:    [[TMP10:%.*]] = zext i8 [[TMP8]] to i64
; CHECK-NEXT:    [[TMP11:%.*]] = zext i8 [[TMP9]] to i64
; CHECK-NEXT:    [[TMP12:%.*]] = xor i64 [[TMP10]], [[TMP11]]
; CHECK-NEXT:    [[TMP13:%.*]] = or i64 [[TMP5]], [[TMP12]]
; CHECK-NEXT:    [[TMP14:%.*]] = icmp ne i64 [[TMP13]], 0
; CHECK-NEXT:    [[TMP15:%.*]] = zext i1 [[TMP14]] to i32
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[TMP15]], 0
; CHECK-NEXT:    [[CONV:%.*]] = zext i1 [[CMP]] to i32
; CHECK-NEXT:    ret i32 [[CONV]]
;
  %call = tail call i32 @memcmp(i8 addrspace(200) * %x, i8 addrspace(200) * %y, i64 9)
  %cmp = icmp eq i32 %call, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

define i32 @cmp_eq10(i8 addrspace(200) * nocapture readonly %x, i8 addrspace(200) * nocapture readonly %y)  {
; CHECK-LABEL: @cmp_eq10(
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i8 addrspace(200)* [[X:%.*]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast i8 addrspace(200)* [[Y:%.*]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP3:%.*]] = load i64, i64 addrspace(200)* [[TMP1]]
; CHECK-NEXT:    [[TMP4:%.*]] = load i64, i64 addrspace(200)* [[TMP2]]
; CHECK-NEXT:    [[TMP5:%.*]] = xor i64 [[TMP3]], [[TMP4]]
; CHECK-NEXT:    [[TMP6:%.*]] = getelementptr i8, i8 addrspace(200)* [[X]], i64 8
; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr i8, i8 addrspace(200)* [[Y]], i64 8
; CHECK-NEXT:    [[TMP8:%.*]] = bitcast i8 addrspace(200)* [[TMP6]] to i16 addrspace(200)*
; CHECK-NEXT:    [[TMP9:%.*]] = bitcast i8 addrspace(200)* [[TMP7]] to i16 addrspace(200)*
; CHECK-NEXT:    [[TMP10:%.*]] = load i16, i16 addrspace(200)* [[TMP8]]
; CHECK-NEXT:    [[TMP11:%.*]] = load i16, i16 addrspace(200)* [[TMP9]]
; CHECK-NEXT:    [[TMP12:%.*]] = zext i16 [[TMP10]] to i64
; CHECK-NEXT:    [[TMP13:%.*]] = zext i16 [[TMP11]] to i64
; CHECK-NEXT:    [[TMP14:%.*]] = xor i64 [[TMP12]], [[TMP13]]
; CHECK-NEXT:    [[TMP15:%.*]] = or i64 [[TMP5]], [[TMP14]]
; CHECK-NEXT:    [[TMP16:%.*]] = icmp ne i64 [[TMP15]], 0
; CHECK-NEXT:    [[TMP17:%.*]] = zext i1 [[TMP16]] to i32
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[TMP17]], 0
; CHECK-NEXT:    [[CONV:%.*]] = zext i1 [[CMP]] to i32
; CHECK-NEXT:    ret i32 [[CONV]]
;
  %call = tail call i32 @memcmp(i8 addrspace(200) * %x, i8 addrspace(200) * %y, i64 10)
  %cmp = icmp eq i32 %call, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

define i32 @cmp_eq11(i8 addrspace(200) * nocapture readonly %x, i8 addrspace(200) * nocapture readonly %y)  {
; CHECK-LABEL: @cmp_eq11(
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i8 addrspace(200)* [[X:%.*]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast i8 addrspace(200)* [[Y:%.*]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP3:%.*]] = load i64, i64 addrspace(200)* [[TMP1]]
; CHECK-NEXT:    [[TMP4:%.*]] = load i64, i64 addrspace(200)* [[TMP2]]
; CHECK-NEXT:    [[TMP5:%.*]] = xor i64 [[TMP3]], [[TMP4]]
; CHECK-NEXT:    [[TMP6:%.*]] = getelementptr i8, i8 addrspace(200)* [[X]], i64 3
; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr i8, i8 addrspace(200)* [[Y]], i64 3
; CHECK-NEXT:    [[TMP8:%.*]] = bitcast i8 addrspace(200)* [[TMP6]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP9:%.*]] = bitcast i8 addrspace(200)* [[TMP7]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP10:%.*]] = load i64, i64 addrspace(200)* [[TMP8]]
; CHECK-NEXT:    [[TMP11:%.*]] = load i64, i64 addrspace(200)* [[TMP9]]
; CHECK-NEXT:    [[TMP12:%.*]] = xor i64 [[TMP10]], [[TMP11]]
; CHECK-NEXT:    [[TMP13:%.*]] = or i64 [[TMP5]], [[TMP12]]
; CHECK-NEXT:    [[TMP14:%.*]] = icmp ne i64 [[TMP13]], 0
; CHECK-NEXT:    [[TMP15:%.*]] = zext i1 [[TMP14]] to i32
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[TMP15]], 0
; CHECK-NEXT:    [[CONV:%.*]] = zext i1 [[CMP]] to i32
; CHECK-NEXT:    ret i32 [[CONV]]
;
  %call = tail call i32 @memcmp(i8 addrspace(200) * %x, i8 addrspace(200) * %y, i64 11)
  %cmp = icmp eq i32 %call, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

define i32 @cmp_eq12(i8 addrspace(200) * nocapture readonly %x, i8 addrspace(200) * nocapture readonly %y)  {
; CHECK-LABEL: @cmp_eq12(
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i8 addrspace(200)* [[X:%.*]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast i8 addrspace(200)* [[Y:%.*]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP3:%.*]] = load i64, i64 addrspace(200)* [[TMP1]]
; CHECK-NEXT:    [[TMP4:%.*]] = load i64, i64 addrspace(200)* [[TMP2]]
; CHECK-NEXT:    [[TMP5:%.*]] = xor i64 [[TMP3]], [[TMP4]]
; CHECK-NEXT:    [[TMP6:%.*]] = getelementptr i8, i8 addrspace(200)* [[X]], i64 8
; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr i8, i8 addrspace(200)* [[Y]], i64 8
; CHECK-NEXT:    [[TMP8:%.*]] = bitcast i8 addrspace(200)* [[TMP6]] to i32 addrspace(200)*
; CHECK-NEXT:    [[TMP9:%.*]] = bitcast i8 addrspace(200)* [[TMP7]] to i32 addrspace(200)*
; CHECK-NEXT:    [[TMP10:%.*]] = load i32, i32 addrspace(200)* [[TMP8]]
; CHECK-NEXT:    [[TMP11:%.*]] = load i32, i32 addrspace(200)* [[TMP9]]
; CHECK-NEXT:    [[TMP12:%.*]] = zext i32 [[TMP10]] to i64
; CHECK-NEXT:    [[TMP13:%.*]] = zext i32 [[TMP11]] to i64
; CHECK-NEXT:    [[TMP14:%.*]] = xor i64 [[TMP12]], [[TMP13]]
; CHECK-NEXT:    [[TMP15:%.*]] = or i64 [[TMP5]], [[TMP14]]
; CHECK-NEXT:    [[TMP16:%.*]] = icmp ne i64 [[TMP15]], 0
; CHECK-NEXT:    [[TMP17:%.*]] = zext i1 [[TMP16]] to i32
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[TMP17]], 0
; CHECK-NEXT:    [[CONV:%.*]] = zext i1 [[CMP]] to i32
; CHECK-NEXT:    ret i32 [[CONV]]
;
  %call = tail call i32 @memcmp(i8 addrspace(200) * %x, i8 addrspace(200) * %y, i64 12)
  %cmp = icmp eq i32 %call, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

define i32 @cmp_eq13(i8 addrspace(200) * nocapture readonly %x, i8 addrspace(200) * nocapture readonly %y)  {
; CHECK-LABEL: @cmp_eq13(
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i8 addrspace(200)* [[X:%.*]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast i8 addrspace(200)* [[Y:%.*]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP3:%.*]] = load i64, i64 addrspace(200)* [[TMP1]]
; CHECK-NEXT:    [[TMP4:%.*]] = load i64, i64 addrspace(200)* [[TMP2]]
; CHECK-NEXT:    [[TMP5:%.*]] = xor i64 [[TMP3]], [[TMP4]]
; CHECK-NEXT:    [[TMP6:%.*]] = getelementptr i8, i8 addrspace(200)* [[X]], i64 5
; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr i8, i8 addrspace(200)* [[Y]], i64 5
; CHECK-NEXT:    [[TMP8:%.*]] = bitcast i8 addrspace(200)* [[TMP6]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP9:%.*]] = bitcast i8 addrspace(200)* [[TMP7]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP10:%.*]] = load i64, i64 addrspace(200)* [[TMP8]]
; CHECK-NEXT:    [[TMP11:%.*]] = load i64, i64 addrspace(200)* [[TMP9]]
; CHECK-NEXT:    [[TMP12:%.*]] = xor i64 [[TMP10]], [[TMP11]]
; CHECK-NEXT:    [[TMP13:%.*]] = or i64 [[TMP5]], [[TMP12]]
; CHECK-NEXT:    [[TMP14:%.*]] = icmp ne i64 [[TMP13]], 0
; CHECK-NEXT:    [[TMP15:%.*]] = zext i1 [[TMP14]] to i32
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[TMP15]], 0
; CHECK-NEXT:    [[CONV:%.*]] = zext i1 [[CMP]] to i32
; CHECK-NEXT:    ret i32 [[CONV]]
;
  %call = tail call i32 @memcmp(i8 addrspace(200) * %x, i8 addrspace(200) * %y, i64 13)
  %cmp = icmp eq i32 %call, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

define i32 @cmp_eq14(i8 addrspace(200) * nocapture readonly %x, i8 addrspace(200) * nocapture readonly %y)  {
; CHECK-LABEL: @cmp_eq14(
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i8 addrspace(200)* [[X:%.*]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast i8 addrspace(200)* [[Y:%.*]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP3:%.*]] = load i64, i64 addrspace(200)* [[TMP1]]
; CHECK-NEXT:    [[TMP4:%.*]] = load i64, i64 addrspace(200)* [[TMP2]]
; CHECK-NEXT:    [[TMP5:%.*]] = xor i64 [[TMP3]], [[TMP4]]
; CHECK-NEXT:    [[TMP6:%.*]] = getelementptr i8, i8 addrspace(200)* [[X]], i64 6
; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr i8, i8 addrspace(200)* [[Y]], i64 6
; CHECK-NEXT:    [[TMP8:%.*]] = bitcast i8 addrspace(200)* [[TMP6]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP9:%.*]] = bitcast i8 addrspace(200)* [[TMP7]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP10:%.*]] = load i64, i64 addrspace(200)* [[TMP8]]
; CHECK-NEXT:    [[TMP11:%.*]] = load i64, i64 addrspace(200)* [[TMP9]]
; CHECK-NEXT:    [[TMP12:%.*]] = xor i64 [[TMP10]], [[TMP11]]
; CHECK-NEXT:    [[TMP13:%.*]] = or i64 [[TMP5]], [[TMP12]]
; CHECK-NEXT:    [[TMP14:%.*]] = icmp ne i64 [[TMP13]], 0
; CHECK-NEXT:    [[TMP15:%.*]] = zext i1 [[TMP14]] to i32
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[TMP15]], 0
; CHECK-NEXT:    [[CONV:%.*]] = zext i1 [[CMP]] to i32
; CHECK-NEXT:    ret i32 [[CONV]]
;
  %call = tail call i32 @memcmp(i8 addrspace(200) * %x, i8 addrspace(200) * %y, i64 14)
  %cmp = icmp eq i32 %call, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

define i32 @cmp_eq15(i8 addrspace(200) * nocapture readonly %x, i8 addrspace(200) * nocapture readonly %y)  {
; CHECK-LABEL: @cmp_eq15(
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i8 addrspace(200)* [[X:%.*]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast i8 addrspace(200)* [[Y:%.*]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP3:%.*]] = load i64, i64 addrspace(200)* [[TMP1]]
; CHECK-NEXT:    [[TMP4:%.*]] = load i64, i64 addrspace(200)* [[TMP2]]
; CHECK-NEXT:    [[TMP5:%.*]] = xor i64 [[TMP3]], [[TMP4]]
; CHECK-NEXT:    [[TMP6:%.*]] = getelementptr i8, i8 addrspace(200)* [[X]], i64 7
; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr i8, i8 addrspace(200)* [[Y]], i64 7
; CHECK-NEXT:    [[TMP8:%.*]] = bitcast i8 addrspace(200)* [[TMP6]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP9:%.*]] = bitcast i8 addrspace(200)* [[TMP7]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP10:%.*]] = load i64, i64 addrspace(200)* [[TMP8]]
; CHECK-NEXT:    [[TMP11:%.*]] = load i64, i64 addrspace(200)* [[TMP9]]
; CHECK-NEXT:    [[TMP12:%.*]] = xor i64 [[TMP10]], [[TMP11]]
; CHECK-NEXT:    [[TMP13:%.*]] = or i64 [[TMP5]], [[TMP12]]
; CHECK-NEXT:    [[TMP14:%.*]] = icmp ne i64 [[TMP13]], 0
; CHECK-NEXT:    [[TMP15:%.*]] = zext i1 [[TMP14]] to i32
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[TMP15]], 0
; CHECK-NEXT:    [[CONV:%.*]] = zext i1 [[CMP]] to i32
; CHECK-NEXT:    ret i32 [[CONV]]
;
  %call = tail call i32 @memcmp(i8 addrspace(200) * %x, i8 addrspace(200) * %y, i64 15)
  %cmp = icmp eq i32 %call, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

define i32 @cmp_eq16(i8 addrspace(200) * nocapture readonly %x, i8 addrspace(200) * nocapture readonly %y)  {
; CHECK-LABEL: @cmp_eq16(
; CHECK-NEXT:    [[TMP1:%.*]] = bitcast i8 addrspace(200)* [[X:%.*]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP2:%.*]] = bitcast i8 addrspace(200)* [[Y:%.*]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP3:%.*]] = load i64, i64 addrspace(200)* [[TMP1]]
; CHECK-NEXT:    [[TMP4:%.*]] = load i64, i64 addrspace(200)* [[TMP2]]
; CHECK-NEXT:    [[TMP5:%.*]] = xor i64 [[TMP3]], [[TMP4]]
; CHECK-NEXT:    [[TMP6:%.*]] = getelementptr i8, i8 addrspace(200)* [[X]], i64 8
; CHECK-NEXT:    [[TMP7:%.*]] = getelementptr i8, i8 addrspace(200)* [[Y]], i64 8
; CHECK-NEXT:    [[TMP8:%.*]] = bitcast i8 addrspace(200)* [[TMP6]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP9:%.*]] = bitcast i8 addrspace(200)* [[TMP7]] to i64 addrspace(200)*
; CHECK-NEXT:    [[TMP10:%.*]] = load i64, i64 addrspace(200)* [[TMP8]]
; CHECK-NEXT:    [[TMP11:%.*]] = load i64, i64 addrspace(200)* [[TMP9]]
; CHECK-NEXT:    [[TMP12:%.*]] = xor i64 [[TMP10]], [[TMP11]]
; CHECK-NEXT:    [[TMP13:%.*]] = or i64 [[TMP5]], [[TMP12]]
; CHECK-NEXT:    [[TMP14:%.*]] = icmp ne i64 [[TMP13]], 0
; CHECK-NEXT:    [[TMP15:%.*]] = zext i1 [[TMP14]] to i32
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[TMP15]], 0
; CHECK-NEXT:    [[CONV:%.*]] = zext i1 [[CMP]] to i32
; CHECK-NEXT:    ret i32 [[CONV]]
;
  %call = tail call i32 @memcmp(i8 addrspace(200) * %x, i8 addrspace(200) * %y, i64 16)
  %cmp = icmp eq i32 %call, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}
